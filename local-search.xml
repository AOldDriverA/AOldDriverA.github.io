<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>通视分析</title>
    <link href="/2020/09/08/%E9%80%9A%E8%A7%86%E5%88%86%E6%9E%90/"/>
    <url>/2020/09/08/%E9%80%9A%E8%A7%86%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="通视分析，以Cesium为例"><a href="#通视分析，以Cesium为例" class="headerlink" title="通视分析，以Cesium为例"></a><center>通视分析，以Cesium为例</center></h1><p>回顾一下通视分析的实现场景！先来张效果图。虽然网上例子一大堆，但有些没讲透彻有些直接上代码，要看懂还有有些烦，所以本文希望能填补这些缺点，先将原理，然后将思路同时结合代码（代码中也有详细的注释）。现在开源的知识很多，但只有学会了才是自己的。</p><p><img src="https://raw.githubusercontent.com/AOldDriverA/BlogFigurebed/master/img/image-20200923104525833.png" srcset="/img/loading.gif" alt="image-20200923104525833"></p><p>在开始一个小功能开发之前，先明确应用的效果或者最终展现出来的效果是什么样的。通视分析或者可视域分析就是将一个模拟的视点在一定视角情况下哪些是可见的、不可见的呈现出来。进一步描述一下，首先需要一个模拟的视点（可以通过鼠标点选），然后需要一个四棱锥或圆锥体来可视化视锥体（并能随着鼠标点进行移动），最后需要将模拟视点可见区域着上色为绿色，不可见为红色。最终要实现的效果出来之后，就开始分别实现了。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>因为是展示模拟视点在模拟视角（视锥体）的情况下可见、不可见情况，所以，只需要将真正的相机放在模拟视点并设置模拟视角为相机的视角，此时相机中就记录了该点该视线方向和视角的情况下可见区域，然后进入webGL图形管线，经过光栅化后，将可见区域离散化到纹理缓冲区中的一个个像素上。像素有RGBA四个分量，一般存的是颜色，当然，你存该像素对应物体到该像素（像素位于近裁剪面上）的距离也没一点问题，纹理缓冲区完全听你的，所以咱们就这样做，把各个像素与其所表示物体间距离存到像素的RBGA分量上（整形）。然后把所有像素所在的纹理缓冲区保存起来，后面使用。</p><p>一个世界如果想描述所有物体，必须有一个统一和唯一坐标，称之为世界坐标，大家只有有一个公共的桥梁联通才能相互交流嘛，物体本身有局部坐标系，然后通过模型视图矩阵变换到世界坐标系，再通过投影变换到近裁剪面上的坐标；同样可以通过投影变换逆变换到世界坐标系，再通过视图模型矩阵最终变换会局部坐标系。啰嗦这些不是为了将你们绕晕，咱们屏幕中所见的是真实相机的真实视锥体近裁剪面上画面，当然屏幕中的像素也对应近裁剪面离散化后结果，也就是说，咱们可以确定屏幕中像素对应的近裁剪面坐标，然后从视点发出射线，穿过该像素的近裁剪面坐标，计算与场景中物体的交点，这一步用到了投影变换一边换—近裁剪面坐标转为世界坐标，计算出来的交点就是世界坐标，然后世界坐标在通过模拟视点、模拟视锥体对应的投影变换变换到模拟视锥体近裁剪面上，找到离散化后对应的像素坐标，就得到了交点与像素之间的距离。还记得上一段中保存起来的纹理缓冲区么？根据像素坐标去里面取出相应像素的值也就是像素到物体的距离，然后和这个像素与交点的距离进行比较，如果交点与像素的距离大于像素与物体距离，则说明交点位于模拟视点的不可见处，即阴影处，然后交点所在的物体在真实相机视角下就应该是红色（因为该点在模拟视点中不可见）。没图硬扯不知你们会不会晕。</p><h3 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h3><p>算是正式开始前的准备工作，先开启阴影和深度缓冲区，只有开启了深度缓冲区，才能缓存深度（也就是物体与像素的距离）信息，只有开启阴影，地面上才能显示阴影。因为可见不可见本身是通过阴影的原理实现的。然后绑定鼠标事件，这里主要用到了鼠标左键双击和移动事件，构想是这样的，鼠标双击选点，然后移动调整观察方向，最终再次双击选择终点，得到完整的通视分析效果。具体解析通过代码结合注释食用。这里将鼠标移动的绑定事件放到了鼠标左键双击绑定里，只有选点时的双击触发时，才会进行下一步的鼠标移动绑定，选点结束的鼠标双击会自动结束鼠标移动绑定。</p><pre><code class="hljs javascript"><span class="hljs-comment">// 开启地形接受和投射阴影. ENABLED表示即接受阴影也投射阴影，DISABLED表示不接受也不投射，</span><span class="hljs-comment">// CAST_ONLY表示只投射阴影，RECEIVE_ONLY表示只接受阴影</span><span class="hljs-keyword">this</span>.viewer.terrainShadows = Cesium.ShadowMode.ENABLED;<span class="hljs-comment">// 开启地形的深度测试</span><span class="hljs-keyword">this</span>.depthTest = <span class="hljs-keyword">this</span>.viewer.scene.globe.depthTestAgainstTerrain;<span class="hljs-comment">// 初始化鼠标点击事件</span><span class="hljs-keyword">this</span>.mouseHandler = <span class="hljs-keyword">new</span> Cesium.ScreenSpaceEventHandler(<span class="hljs-keyword">this</span>.viewer.scene.canvas);<span class="hljs-comment">// 添加鼠标左键点击事件</span><span class="hljs-comment">// 第一次点击选择模拟观察点位置</span><span class="hljs-comment">// 第二次点击选择模拟视锥体的结束位置</span><span class="hljs-keyword">this</span>.mouseHandler.setInputAction(<span class="hljs-function">(<span class="hljs-params">mouseClickEvent</span>) =&gt;</span> &#123;  <span class="hljs-comment">// 说明是第一次点击</span>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isDrawViewshed) &#123;    <span class="hljs-comment">// 获取模拟观察点的三维坐标（由二维屏幕坐标转换得到）</span>    <span class="hljs-keyword">this</span>.viewPoint = <span class="hljs-keyword">this</span>.viewer.camera.pickEllipsoid(mouseClickEvent.position);    <span class="hljs-keyword">this</span>.viewPoint = Cesium.Cartesian3.fromDegrees(<span class="hljs-number">116.3411</span>, <span class="hljs-number">39.9955</span>, <span class="hljs-number">50</span>);    <span class="hljs-comment">// 不管之前的面片有没有，都清空一次</span>    <span class="hljs-keyword">this</span>.frustumEntities = [];    <span class="hljs-comment">// 创建视锥体，主要是初始化主体函数，并修改了源代码，来选定可见、不可见区域颜色</span>    <span class="hljs-keyword">this</span>.createViewshed(<span class="hljs-keyword">this</span>.viewPoint);    <span class="hljs-comment">// 绘制模拟观察点（确实是一个点）</span>    <span class="hljs-keyword">this</span>.viewPointGeometry = <span class="hljs-keyword">this</span>.viewer.entities.add(&#123;      position: <span class="hljs-keyword">this</span>.viewPoint,      point: &#123;        pixelSize: <span class="hljs-number">12</span>,        color: Cesium.Color.YELLOW,        disableDepthTestDistance: <span class="hljs-built_in">Number</span>.POSITIVE_INFINITY      &#125;    &#125;)    <span class="hljs-comment">// 添加鼠标移动事件（之所以放到这里面为了提高效率）</span>    <span class="hljs-keyword">this</span>.mouseHandler.setInputAction(<span class="hljs-function">(<span class="hljs-params">mouseMoveEvent</span>) =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isDrawViewshed) &#123;        <span class="hljs-keyword">this</span>.viewEndPoint = <span class="hljs-keyword">this</span>.viewer.scene.pickPosition(mouseMoveEvent.endPosition);        <span class="hljs-comment">// 计算更新视锥体姿态</span>        <span class="hljs-keyword">this</span>.calculatePose();        <span class="hljs-comment">// 根据姿态创建变换矩阵和视锥体点并绘制</span>        <span class="hljs-keyword">this</span>.createFrustum();      &#125;    &#125;, Cesium.ScreenSpaceEventType.MOUSE_MOVE);    <span class="hljs-keyword">this</span>.isDrawViewshed = <span class="hljs-literal">true</span>;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// 说明是第二次点击，此时已经选好了模拟视锥体的终点</span>    <span class="hljs-keyword">this</span>.isDrawViewshed = <span class="hljs-literal">false</span>;    <span class="hljs-comment">// 解除鼠标移动事件</span>    <span class="hljs-keyword">this</span>.mouseHandler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);  &#125;&#125;, Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);</code></pre><h3 id="2-绘制顶点"><a href="#2-绘制顶点" class="headerlink" title="2.绘制顶点"></a>2.绘制顶点</h3><p>第一次点击时确定模拟观察点，然后初始化视锥体createViewshed()</p><p>从<strong>原理</strong>中可知，模拟视点和模拟视锥体本质也相当于一个相机，为了更好的描述模拟视锥体，在createViewshed函数中，创建了一个对象：spotLight，类型为相机类型Camera，frustum属性就是视锥体属性，这里fov、aspectRatio、near和far是我随意赋值的，使用时可以外部传参。然后构造shadowOptions。为什么要构造shadowOptions？因为可以借用cesium自身提供的阴影缓冲区，这一块后面有时间的话会详细说的。最后更改cesium的glsl，将可见的不可见的设置为绿色和红色。</p><pre><code class="hljs javascript"><span class="hljs-comment">// 这里构造了一个Camera类来模拟视锥体，因为视锥体和相机是紧密结合的，视锥体会用到相机里的一些方法</span><span class="hljs-keyword">this</span>.spotLight = <span class="hljs-keyword">new</span> Cesium.Camera(<span class="hljs-keyword">this</span>.viewer.scene);<span class="hljs-keyword">this</span>.spotLight.position = position;<span class="hljs-comment">// 设置视锥体参数</span><span class="hljs-keyword">this</span>.spotLight.frustum.fov = Cesium.Math.PI_OVER_THREE;<span class="hljs-keyword">this</span>.spotLight.frustum.aspectRatio = <span class="hljs-number">1.0</span>;<span class="hljs-keyword">this</span>.spotLight.frustum.near = <span class="hljs-number">1.0</span>;<span class="hljs-keyword">this</span>.spotLight.frustum.far = <span class="hljs-number">10.0</span>;<span class="hljs-comment">// 设置阴影参数</span><span class="hljs-keyword">this</span>.shadowOptions = &#123;  context: <span class="hljs-keyword">this</span>.viewer.scene.context,  enabled: <span class="hljs-literal">true</span>,  lightCamera: <span class="hljs-keyword">this</span>.spotLight,  maximumDistance: <span class="hljs-number">5000.0</span>,  size: <span class="hljs-number">4096</span>,  cascadesEnabled: <span class="hljs-literal">false</span>&#125;<span class="hljs-comment">// 创建阴影（利用Cesium写好的类）</span><span class="hljs-keyword">this</span>.viewer.scene.shadowMap = <span class="hljs-keyword">new</span> Cesium.ShadowMap(<span class="hljs-keyword">this</span>.shadowOptions);<span class="hljs-comment">// 修改glsl来改变颜色（修改Cesium写好的类）</span><span class="hljs-keyword">let</span> createShadowReceiveFragmentShader = Cesium.ShadowMapShader.createShadowReceiveFragmentShader;Cesium.ShadowMapShader.createShadowReceiveFragmentShader = <span class="hljs-function">(<span class="hljs-params">fs, shadowMap, castShadows, isTerrain, hasTerrainNormal</span>) =&gt;</span> &#123;  <span class="hljs-keyword">let</span> fragmentShader = createShadowReceiveFragmentShader(fs, shadowMap, castShadows, isTerrain, hasTerrainNormal);  <span class="hljs-keyword">let</span> colorFS = <span class="hljs-string">` if (visibility == 1.0) &#123;</span><span class="hljs-string">gl_FragColor.rgb *= vec3(0.2, 1.0, 0.2);</span><span class="hljs-string">&#125; else &#123;</span><span class="hljs-string">gl_FragColor.rgb *= vec3(1.0, 0.2, 0.2);</span><span class="hljs-string">&#125;`</span>;  fragmentShader.sources[fragmentShader.sources.length - <span class="hljs-number">1</span>] = fragmentShader.sources[fragmentShader.sources.length - <span class="hljs-number">1</span>].replace(<span class="hljs-string">'gl_FragColor.rgb *= visibility'</span>, colorFS);  <span class="hljs-keyword">return</span> fragmentShader;&#125;</code></pre><h3 id="3-根据MOUSE-MOVE计算视锥体姿态"><a href="#3-根据MOUSE-MOVE计算视锥体姿态" class="headerlink" title="3.根据MOUSE_MOVE计算视锥体姿态"></a>3.根据MOUSE_MOVE计算视锥体姿态</h3><p>下段代码是calculatePose()函数，计算视锥体姿态其实就是计算局部坐标系下模拟视锥体（后文除非特殊说明，否则视锥体都是指模拟视锥体）自身的direction、right和up三个轴的指向（三个轴两两之间垂直）。局部坐标系指的是ENU（east、north、up）坐标系，正常情况下，知道direction和up就当相当于知道了模型变换，Cesium使用direction和up计算出heading、pitch、roll。注意！Cesium的heading、pitch、roll围绕的换转轴分别指向down、west和south也就是和up、east、north<strong>正好相反</strong>，后面还会说的。</p><p>那么，direction怎么求呢？鼠标移动的点作为终点，鼠标双击时选的模拟视点作为起点，这样：终点 - 起点 = direction（向量）。然后计算right轴，起点本身也是一个向量，它是原点指向起点的这么非单位向量，先对其归一化，direction叉乘这个归一化后的向量得到right向量，right向量叉乘direction得到up向量。注意两个数叉乘的先后顺序影响结果向量的指向（指向正轴还是负轴）。然后巧妙的借用Cesium中camera函数的setView方法，通过up和direction得到对应的heading、pitch、roll。</p><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.viewEndPoint) <span class="hljs-keyword">return</span>;<span class="hljs-comment">// 可视域的视线向量（direction）</span><span class="hljs-keyword">this</span>.viewDirection = <span class="hljs-keyword">new</span> Cesium.Cartesian3();Cesium.Cartesian3.subtract(<span class="hljs-keyword">this</span>.viewEndPoint, <span class="hljs-keyword">this</span>.viewPoint, <span class="hljs-keyword">this</span>.viewDirection);<span class="hljs-comment">// 向量长度(模拟观察点到模拟观察视锥体远裁剪面距离)</span><span class="hljs-keyword">this</span>.frustumFar = Cesium.Cartesian3.magnitude(<span class="hljs-keyword">this</span>.viewDirection);<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.frustumFar &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<span class="hljs-comment">// 归一化向量</span>Cesium.Cartesian3.normalize(<span class="hljs-keyword">this</span>.viewDirection, <span class="hljs-keyword">this</span>.viewDirection);<span class="hljs-comment">// 保存当前viewer中相机的以下信息，因为待会会带入模拟观察视锥体</span><span class="hljs-keyword">let</span> curView = <span class="hljs-keyword">this</span>.viewer.scene.frameState.camera;<span class="hljs-keyword">let</span> curViewHeading = curView.heading;<span class="hljs-keyword">let</span> curViewPitch = curView.pitch;<span class="hljs-keyword">let</span> curViewRoll = curView.roll;<span class="hljs-keyword">let</span> curViewCameraPosition = <span class="hljs-keyword">new</span> Cesium.Cartesian3();Cesium.Cartesian3.clone(curView.position, curViewCameraPosition);<span class="hljs-keyword">let</span> curViewPoint = <span class="hljs-keyword">this</span>.viewPoint.clone();Cesium.Cartesian3.normalize(curViewPoint, curViewPoint);<span class="hljs-comment">// 视锥体局部坐标系下的right轴</span><span class="hljs-comment">// 下面步骤中叉乘的参数顺序一定要注意</span><span class="hljs-keyword">this</span>.right = <span class="hljs-keyword">new</span> Cesium.Cartesian3();Cesium.Cartesian3.cross(curViewPoint, <span class="hljs-keyword">this</span>.viewDirection, <span class="hljs-keyword">this</span>.right);Cesium.Cartesian3.normalize(<span class="hljs-keyword">this</span>.right, <span class="hljs-keyword">this</span>.right);<span class="hljs-comment">// 视锥体局部坐标系下的up轴</span><span class="hljs-keyword">this</span>.up = <span class="hljs-keyword">new</span> Cesium.Cartesian3();Cesium.Cartesian3.cross(<span class="hljs-keyword">this</span>.viewDirection, <span class="hljs-keyword">this</span>.right, <span class="hljs-keyword">this</span>.up);Cesium.Cartesian3.normalize(<span class="hljs-keyword">this</span>.up, <span class="hljs-keyword">this</span>.up);<span class="hljs-comment">// 借用Cesium中自带的Camera方法获取模拟观察视锥体的heading、pitch、roll</span><span class="hljs-comment">// 省去了一大波麻烦事，以后有时间再研究一波</span>curView.setView(&#123;  destination: <span class="hljs-keyword">this</span>.viewPoint,  orientation: &#123;    direction: <span class="hljs-keyword">this</span>.viewDirection,    up: <span class="hljs-keyword">this</span>.up  &#125;&#125;)<span class="hljs-keyword">this</span>.heading = curView.heading;<span class="hljs-keyword">this</span>.pitch = curView.pitch;<span class="hljs-keyword">this</span>.roll = curView.roll;<span class="hljs-comment">// 再回退到正常的Camera（用完人家的方法得给人家恢复到之前的状态）</span>curView.setView(&#123;  destination: curViewCameraPosition,  orientation: &#123;    heading: curViewHeading,    pitch: curViewPitch,    roll: curViewRoll  &#125;&#125;);<span class="hljs-keyword">this</span>.spotLight.frustum.far = <span class="hljs-keyword">this</span>.frustumFar;<span class="hljs-keyword">this</span>.shadowOptions.maximumDistance = <span class="hljs-keyword">this</span>.frustumFar;<span class="hljs-keyword">this</span>.spotLight.setView(&#123;  destination: <span class="hljs-keyword">this</span>.viewPoint,  orientation: &#123;    heading: <span class="hljs-keyword">this</span>.heading,    pitch: <span class="hljs-keyword">this</span>.pitch,    roll: <span class="hljs-keyword">this</span>.roll  &#125;&#125;)</code></pre><h3 id="4-根据姿态计算变换矩阵"><a href="#4-根据姿态计算变换矩阵" class="headerlink" title="4.根据姿态计算变换矩阵"></a>4.根据姿态计算变换矩阵</h3><p>下面是createFrustum函数</p><p>简单的说，就是由heading、pitch、roll代表ENU局部坐标系下的姿态，然后将其转为四元数，再由四元数转为矩阵就得到了heading、pitch、roll对应的局部坐标系下的变换矩阵，再左乘模型变换矩阵（Cesium.Transforms.eastNorthUpToFixedFrame(this.viewPoint)）将模型从局部坐标系变换到世界坐标系，最终就得到了heading、pitch、roll对应的世界坐标系。</p><p>然后局部坐标系下创建一个视锥体，主要就是计算视锥体各个顶点的位置、顶点索引（webGL那一块），然后构造视锥体线框并添加，这样就可以看到视锥体了。话不多说，都在代码里。这里主要说明思路，所以为了性能很多都直接变量直接写死成了常数，比如视锥体fov是π/2等，生产环境下还是得根据输入参数来。</p><pre><code class="hljs javascript"><span class="hljs-comment">/** 1.先计算变换矩阵 */</span><span class="hljs-comment">// 注意，heading、pitch、roll的轴方向正好和局部坐标系east、north、up相反</span><span class="hljs-comment">// heading轴是down，pitch轴左向（west），roll轴是后向（south），所以对pitch、roll取反</span><span class="hljs-comment">// heading + 1.5707963是因为默认情况下heading指向正西，需要加Π / 2 = 45°换算成弧度是1.5707963旋转到正北</span><span class="hljs-keyword">let</span> hpr = <span class="hljs-keyword">new</span> Cesium.HeadingPitchRoll(<span class="hljs-keyword">this</span>.heading + <span class="hljs-number">1.5707963</span>, -<span class="hljs-keyword">this</span>.pitch, -<span class="hljs-keyword">this</span>.roll);<span class="hljs-comment">// 四元数</span><span class="hljs-keyword">let</span> Qua = Cesium.Quaternion.fromHeadingPitchRoll(hpr);<span class="hljs-comment">// 再通过四元数计算出旋转矩阵，注意，以上无论是hpr还是Qua都是局部坐标系</span><span class="hljs-comment">// 通俗的说就是地球上你所在的局部坐标系上北下南（x轴）左西右东（y轴）头顶为上（z轴）这种</span><span class="hljs-keyword">let</span> rotMatrix = Cesium.Matrix3.fromQuaternion(Qua);<span class="hljs-comment">// 下面这部是将你的局部坐标系准换到地球球心三维坐标系（比如x轴为0度经纬度交点和球心连线，z轴为球心和几点连线）</span><span class="hljs-keyword">let</span> modelMatrix = Cesium.Matrix4.multiply(  <span class="hljs-comment">// 这一步对应于渲染管线中的局部坐标系变换到世界坐标系</span>  Cesium.Transforms.eastNorthUpToFixedFrame(<span class="hljs-keyword">this</span>.viewPoint),  <span class="hljs-comment">// 对应于局部坐标系下的位置变换矩阵</span>  Cesium.Matrix4.fromRotationTranslation(rotMatrix, <span class="hljs-keyword">new</span> Cesium.Cartesian3(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>)),  <span class="hljs-keyword">this</span>.stretchMatrix);<span class="hljs-comment">/** 2.局部坐标系下计算构建视锥体需要的顶点数据 */</span><span class="hljs-comment">// 描述一个金字塔需要5个点，同理，描述一个视锥体也是</span><span class="hljs-keyword">let</span> viewshedPoints = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Float64Array</span>(<span class="hljs-number">5</span> * <span class="hljs-number">3</span>);<span class="hljs-comment">// 绘制视锥体的线框</span><span class="hljs-keyword">let</span> viewshedIndices = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint32Array</span>(<span class="hljs-number">16</span>);<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> tempPosition = <span class="hljs-keyword">this</span>.frustumFar * <span class="hljs-number">0.57735</span>;<span class="hljs-comment">// 模拟观察点默认为局部坐标系原点（金字塔的顶点）</span>viewshedPoints[index++] = <span class="hljs-number">0</span>;viewshedPoints[index++] = <span class="hljs-number">0</span>;viewshedPoints[index++] = <span class="hljs-number">0</span>;<span class="hljs-comment">// 模拟观察视锥体远裁剪面左下角坐标</span>viewshedPoints[index++] = -<span class="hljs-keyword">this</span>.frustumFar;viewshedPoints[index++] = -tempPosition;    <span class="hljs-comment">// y轴，0.57735为tan30</span>viewshedPoints[index++] = -tempPosition;    <span class="hljs-comment">// z轴，0.57735为tan30</span><span class="hljs-comment">// 模拟观察视锥体远裁剪面右下角坐标</span>viewshedPoints[index++] = -<span class="hljs-keyword">this</span>.frustumFar;viewshedPoints[index++] = tempPosition;viewshedPoints[index++] = -tempPosition;<span class="hljs-comment">// 模拟观察视锥体远裁剪面右上角坐标</span>viewshedPoints[index++] = -<span class="hljs-keyword">this</span>.frustumFar;viewshedPoints[index++] = tempPosition;viewshedPoints[index++] = tempPosition;<span class="hljs-comment">// 模拟观察视锥体远裁剪面左上角坐标</span>viewshedPoints[index++] = -<span class="hljs-keyword">this</span>.frustumFar;viewshedPoints[index++] = -tempPosition;viewshedPoints[index++] = tempPosition;index = <span class="hljs-number">0</span>;<span class="hljs-comment">// 构造绘制线框时时用到的索引</span>viewshedIndices[index++] = <span class="hljs-number">0</span>;               <span class="hljs-comment">// 模拟观察点</span>viewshedIndices[index++] = <span class="hljs-number">1</span>;               <span class="hljs-comment">// 左下角点</span>viewshedIndices[index++] = <span class="hljs-number">0</span>;viewshedIndices[index++] = <span class="hljs-number">2</span>;               <span class="hljs-comment">// 右下角点</span>viewshedIndices[index++] = <span class="hljs-number">0</span>;viewshedIndices[index++] = <span class="hljs-number">3</span>;               <span class="hljs-comment">// 右上角点</span>viewshedIndices[index++] = <span class="hljs-number">0</span>;viewshedIndices[index++] = <span class="hljs-number">4</span>;               <span class="hljs-comment">// 左上角点</span>viewshedIndices[index++] = <span class="hljs-number">1</span>;viewshedIndices[index++] = <span class="hljs-number">2</span>;viewshedIndices[index++] = <span class="hljs-number">2</span>;viewshedIndices[index++] = <span class="hljs-number">3</span>;viewshedIndices[index++] = <span class="hljs-number">3</span>;viewshedIndices[index++] = <span class="hljs-number">4</span>;viewshedIndices[index++] = <span class="hljs-number">4</span>;viewshedIndices[index++] = <span class="hljs-number">1</span>;<span class="hljs-comment">/** 3.根据计算的数据，创建视锥体 */</span><span class="hljs-comment">// 相当于webGL中包含顶点和颜色的缓冲区</span><span class="hljs-keyword">let</span> frustumAttributes = <span class="hljs-keyword">new</span> Cesium.GeometryAttributes(&#123;  position: <span class="hljs-keyword">new</span> Cesium.GeometryAttribute(&#123;    componentDatatype: Cesium.ComponentDatatype.DOUBLE,    componentsPerAttribute: <span class="hljs-number">3</span>,    values: viewshedPoints  &#125;)&#125;)<span class="hljs-comment">// 局部坐标系下的模拟观察视锥体的中心点</span><span class="hljs-keyword">let</span> viewshedCenter = <span class="hljs-keyword">new</span> Cesium.Cartesian3(<span class="hljs-keyword">this</span>.frustumFar * <span class="hljs-number">-0.5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">let</span> frustumGeometry = <span class="hljs-keyword">new</span> Cesium.Geometry(&#123;  attributes: frustumAttributes,  indices: viewshedIndices,  primitiveType: Cesium.PrimitiveType.LINES,  boundingSphere: <span class="hljs-keyword">new</span> Cesium.BoundingSphere(viewshedCenter, <span class="hljs-keyword">this</span>.frustumFar * <span class="hljs-number">1.1547</span>) <span class="hljs-comment">// cos30° = 1 / 1.1547 = 0.8660254</span>&#125;)<span class="hljs-keyword">let</span> frustumOutlineInstance = <span class="hljs-keyword">new</span> Cesium.GeometryInstance(&#123;  geometry: frustumGeometry,  modelMatrix: modelMatrix,  attributes: &#123;    color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.CRIMSON)  &#125;&#125;)<span class="hljs-keyword">let</span> frustumOutlineGeometry = <span class="hljs-keyword">new</span> Cesium.Primitive(&#123;  geometryInstances: frustumOutlineInstance,  asynchronous: <span class="hljs-literal">false</span>,  appearance: <span class="hljs-keyword">new</span> Cesium.PerInstanceColorAppearance(&#123;    flat: <span class="hljs-literal">true</span>,    translucent: <span class="hljs-literal">false</span>  &#125;)&#125;);<span class="hljs-comment">// 更新视锥体</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.frustumOutlineGeometry) <span class="hljs-keyword">this</span>.viewer.scene.primitives.remove(<span class="hljs-keyword">this</span>.frustumOutlineGeometry);<span class="hljs-keyword">this</span>.frustumOutlineGeometry = frustumOutlineGeometry;<span class="hljs-keyword">this</span>.viewer.scene.primitives.add(<span class="hljs-keyword">this</span>.frustumOutlineGeometry);</code></pre><p>主要过程都阐述完毕，下面说个函数入口和出口。viewshed是个类名。</p><pre><code class="hljs javascript"><span class="hljs-comment">// 构造函数属性</span><span class="hljs-keyword">constructor</span>(viewer) &#123;  <span class="hljs-keyword">this</span>.viewer = viewer;  <span class="hljs-keyword">this</span>.mouseHandler = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 是否开启了同时分析</span>  <span class="hljs-keyword">this</span>.isDrawViewshed = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 模拟观察点</span>  <span class="hljs-keyword">this</span>.viewPoint = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 远裁剪面中心点(该点 - 观察点 = 观察向量)</span>  <span class="hljs-keyword">this</span>.viewEndPoint = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 视锥体</span>  <span class="hljs-keyword">this</span>.spotLight = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 构建Cesium中的shadowMap时需要的参数</span>  <span class="hljs-keyword">this</span>.shadowOptions = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 是否开启了深度测试</span>  <span class="hljs-keyword">this</span>.depthTest = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 描述视锥体的四个面片</span>  <span class="hljs-keyword">this</span>.frustumEntities = [];  <span class="hljs-comment">// 模拟观察点到模拟视锥体远裁剪面的距离</span>  <span class="hljs-keyword">this</span>.frustumFar = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 局部坐标系下的heading、pitch、roll</span>  <span class="hljs-keyword">this</span>.heading = <span class="hljs-literal">null</span>;  <span class="hljs-keyword">this</span>.pitch = <span class="hljs-literal">null</span>;  <span class="hljs-keyword">this</span>.roll = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 局部坐标系的轴</span>  <span class="hljs-keyword">this</span>.viewDirection = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// up表示上方向</span>  <span class="hljs-keyword">this</span>.up = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// right表示和up、viewDirection都垂直的轴，三个轴构成空间直角坐标系</span>  <span class="hljs-comment">// 但一般只用到up和direction，一般先求direction，然后计算出right，最后由direction和right计算出up</span>  <span class="hljs-keyword">this</span>.right = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 模拟视锥体的线框</span>  <span class="hljs-keyword">this</span>.frustumOutlineGeometry = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 视线方向</span>  <span class="hljs-keyword">this</span>.viewDirectionGeometry = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// up轴</span>  <span class="hljs-keyword">this</span>.viewUpGeometry = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// right轴</span>  <span class="hljs-keyword">this</span>.viewRightGeometry = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 没用的变量</span>  <span class="hljs-keyword">this</span>.stretchMatrix = <span class="hljs-keyword">new</span> Cesium.Matrix4();&#125;<span class="hljs-comment">// 函数入口</span>startViewshed() &#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isDrawViewshed) <span class="hljs-keyword">return</span>;  <span class="hljs-keyword">this</span>.init();&#125;<span class="hljs-comment">// 函数出口</span>endViewshed() &#123;  <span class="hljs-keyword">this</span>.isDrawViewshed = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 解除鼠标绑定事件</span>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.mouseHandler) &#123;    <span class="hljs-keyword">this</span>.mouseHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);    <span class="hljs-comment">// 这里问了保险起见，再次解除鼠标移动事件绑定</span>    <span class="hljs-keyword">this</span>.mouseHandler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);  &#125;  <span class="hljs-comment">// 清空所有绘制</span>  <span class="hljs-keyword">this</span>.viewer.entities.remove(<span class="hljs-keyword">this</span>.viewPointGeometry);  <span class="hljs-keyword">this</span>.viewer.scene.primitives.remove(<span class="hljs-keyword">this</span>.frustumOutlineGeometry);  <span class="hljs-keyword">this</span>.viewer.scene.primitives.remove(<span class="hljs-keyword">this</span>.viewDirectionGeometry);  <span class="hljs-keyword">this</span>.viewer.scene.primitives.remove(<span class="hljs-keyword">this</span>.viewUpGeometry);  <span class="hljs-keyword">this</span>.viewer.scene.primitives.remove(<span class="hljs-keyword">this</span>.viewRightGeometry);  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.viewer.scene.shadowMap) &#123;    <span class="hljs-keyword">this</span>.viewer.scene.shadowMap.enabled = <span class="hljs-literal">false</span>;  &#125;  <span class="hljs-comment">// 释放所有资源</span>  <span class="hljs-keyword">this</span>.destory();&#125;</code></pre><p>OVER！Cesium自身封装webGL的流程有时间还是得好好嚼嚼，上文中说的很粗略，比如ShaderSource和ShadowMapShader里的东西就很多，后面有时间也详细说一下（又一个flag立下了）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>视锥体裁剪和背面剔除技术</title>
    <link href="/2020/07/29/%E8%A7%86%E9%94%A5%E4%BD%93%E8%A3%81%E5%89%AA%E5%92%8C%E8%83%8C%E9%9D%A2%E5%89%94%E9%99%A4%E6%8A%80%E6%9C%AF/"/>
    <url>/2020/07/29/%E8%A7%86%E9%94%A5%E4%BD%93%E8%A3%81%E5%89%AA%E5%92%8C%E8%83%8C%E9%9D%A2%E5%89%94%E9%99%A4%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="视锥体裁剪和背面剔除技术—以Cesium为例"><a href="#视锥体裁剪和背面剔除技术—以Cesium为例" class="headerlink" title="视锥体裁剪和背面剔除技术—以Cesium为例"></a><center>视锥体裁剪和背面剔除技术—以Cesium为例<center></h1><p>回顾一下去年这个时候用到的Cesium中的视锥体裁剪和背面剔除技术，当时一个项目涉及到了这个，对源码做了些研究（又臭又长的相关源码硬是全部咽下），专门等到现在全忘光了再来动笔┭┮﹏┭┮。也算是对前端可视化的回顾吧（另外也发现了Cesium视锥体裁剪中的一点小瑕疵）。可视化要填的坑好多（其实是要学的好多），慢慢写吧，慢工出细活（最近时间太紧太紧）。</p><p>首先哈，默认大家对视锥体（也叫视域体）有所了解，如果只想有所了解的话，建议看看大神法克鸡丝的<a href="https://www.cnblogs.com/fuckgiser/p/5883227.html" target="_blank" rel="noopener">文章</a>，已经非常全面和深入了。本文下面只对源码进行分析。</p><p>去年那个项目是这样的，要根据一定的剖分规则在全球范围内画网格（可以想象成普通的经纬网），网格要能够根据视点与球面的距离进行自动加密或粗略，同时要能够切换成单尺度和多尺度的形态，最后要能入眼（效率帧数！）。导师要求提完了，我也茫然了。全球在一般下全绘制出来会有几千个网格，这些网格的坐标是通过计算生成的（不是经纬网那种简单的剖分），而且你鼠标拉近，网格要够自动细分，为了达到纵享丝滑，需要每帧进行计算并绘制而不是采用监听鼠标变化。先费劲算出几千个网格（每个网格四个角点）然后绘制输出，然后一秒钟重复几十次上述过程，如果不进行剪枝，分分钟让你看PPT。渲染一个物体最好的方法就是不去渲染他，所以在座的个位很容易就想到了用视锥体进行裁剪，屏幕外的网格再大再圆再好看再五彩斑斓的黑也和咱没关系：看不到。</p><p>视锥体裁剪，那Cesium是怎么弄得呢？</p><h3 id="什么是视锥体？"><a href="#什么是视锥体？" class="headerlink" title="什么是视锥体？"></a>什么是<strong>视锥体</strong>？</h3><p>本质就是一叶障目，近大远小。世界从各个方向反射过来的光，经过瞳孔、晶状体（可以想象成透镜，调节焦点）最终投射到视网膜上（倒立的像），然后再由什么视锥、视杆细胞处理，就看到残酷的现实了。注意，那么大的世界，最终透过瞳孔汇聚一点，然后倒立成像，接收到的所有光在这个传播过程中的路径本身就是类似圆锥一样，如下图，两条红色的线就想两个圆锥的斜边轮廓。因为人眼也是有视角范围的，你不可能看到你背后的头皮屑，实际上，眼睛真正的注视区域很小，你只关心眼前的人行道和手机，却忽略了眼角过来的车。</p><p><img src="https://raw.githubusercontent.com/AOldDriverA/BlogFigurebed/master/img/ChMkJlegYWeIG9OfAAIdRBUm2bYAAUFvwE8cdEAAh1c228.png" srcset="/img/loading.gif" alt="网图：视网膜成像"></p><p>然后呢？说这些干啥？（好吧，说这些主要是为了凑字）眼睛感光成像的真实物理过程中，光是类似圆锥一样的从四面八方涌过来，三维可视化要想尽可能的模拟真实世界，那么它的模拟光也得从四面八方过来，但人眼有视角范围，所以代表视野范围的圆锥锥角也被近似确定了。圆锥锥角之外的光代表视野范围外的光，可视化过程中被排除不予显示来模拟人眼“看不到”这个过程。用圆锥来表示视域有些问题，最大的问题应该是显示器很少是圆的、目标裁剪、投影计算复杂（我自己猜的，欢迎大家讨论和指正），所以图形学中用四棱锥（或四棱台）来表示视域，然后投影也很方便，最终变成了规范化立方体。所以视锥体就是计算机模拟人眼成像的过程同时又结合计算特点得到的一个椎体，椎体内的物体代表能看到，最终会显示到屏幕上。等等，除了椎体还有其他的？当然！因为不是所有的可视化都是为了反映真实的世界。初中时的三视图，大学时的CAD制图，现实中的远处物体，他们不再符合近大远小的特点（或者近大远小不再明显），因为他们的光入眼不是锥形路径，而是近似平行，这就是正射投影，或者说平行投影，物体大小和自身属性有关，和观察距离无关，这种投影主要用在建筑工程上等。一般的可视化引擎都会提供这两种。本文以第一种视锥体为主为例进行讲解。</p><p>在这之前先了解一下视锥体。一个视锥体需要具有四个侧面，一个近裁剪面一个远裁剪面， 这里用的是相机的视锥体（当然也可以自己定制一个视锥体），说一下，Cesium中有两个相机，一个是<code>viewer.camera</code>， 一个是<code>scene.camera</code>，其实就是同一个，camera是在viewer初始化时在widget中隐示创建Scene的时候在Scene中生成的，然后viewer的getter函数返回<code>viewer.scene.camera</code>（不知道你们有没有被我故意绕晕）。Cesium中的camera包含了大量的属性和方法，属于视锥体的是<code>camera.frustum</code>属性，在Scene中调用<code>PerspectiveFrustum</code><strong>创建</strong>，也就是说相机默认的是透视投影的视锥体。注意，咱们现在说的是视锥体如何生成，而不是相机如何生成，生成视锥体六个面的函数是<code>PerspectiveOffCenterFrustum()</code>。Cesium中的面是用Cartesian4表示，其中x、y、z表示面的法向量，w表示与起点的距离。视锥体被创建后只是简单的赋了默认值，在真正确定相机位置时，才真正开始设置（Cesium的camera的frustum重要属性都有两个，一个是内部属性’_’开头，一个是外部属性,比如<code>frustum.__fov</code>是内部属性，用于控制视锥体，frustum.fov是外部属性，这个不说大家也都明白，之所以提一下是因为当相机属性发生改变时，是先改变外部属性，比如fov，然后判读内部属性是否和外部属性相等fov === _fov，不相等，说明相机属性发生了变化，需要更新）。</p><h3 id="如何构建视锥体？"><a href="#如何构建视锥体？" class="headerlink" title="如何构建视锥体？"></a>如何构建视锥体？</h3><p>下面讲讲视锥体的主要参数：aspectRatio、fov、near、far</p><p>aspectRatio就是屏幕长宽比，默认值为：canvas.clientWidth / canvas.clientHeight。这里说一下，canvas有两个像素宽度，一个是canvas.width、canvas.heigth；另一个是canvas.clientWidth、canvas.clientHeight，第一个是canvas绘制时的像素数，比如200x200，第二个是canvas在屏幕中最终展示的像素数，比如你淘气的将页面里的canvas长宽拉伸了一倍变成了400x400，这时你看到的就是400x400，由200x200拉伸而来，更准确的说，是canvas监听了窗口的变化，也就是每帧都运行该函数，进行了动态的调整。cesium中的configureCanvasSize函数就做的这事，我先获取当前屏幕像素大小比如400x400，然后和设置的canvas.width比如200x200进行比值，pixelRatio=clienHeight / height，最后canvas.width * pixelRatio变成了屏幕一样大小。</p><p>fov就是视场角，也就是下图的α角，默认60°，真正的单位是弧度。除了这个，还有一个垂直视场角fovy，fovy和fov的关系就是，默认fovy和fov是相等的，但当屏幕宽度大于屏幕高度时，fov变成了水平视场角β。</p><p>near是近裁剪面，也就相当于屏幕了，默认为1米，下图点<strong>F、G、L、J</strong>构成的平面。</p><p>far是远裁剪面，就是最远能看多远，默认为5万千米，下图点<strong>A、B、C、D</strong>构成的平面，只有在远近裁剪面之间的物体才能被显示。</p><p>下面是相机的一些参数，对视锥体同样重要，就是相机的<strong>direction</strong>、<strong>right</strong>、<strong>up</strong>三个向量。</p><p>direction相机的方向，cesium中默认指向球心，就是将相机三维坐标归一化再取反就得到了，对应下图中绿轴上的蓝色线段ET，方向同绿轴。</p><p>right相机的左方向，对应图中的红轴，方向同红轴，由$direction \times Z$得到。Z指的是笛卡尔坐标系中的Z轴。</p><p>up相机的上方向，对应图中的蓝色偏紫色的上方向那个轴，由$right \times direction$得到。后面用到的direction、right、up不加特别说明都是这仨</p><p><img src="https://raw.githubusercontent.com/AOldDriverA/BlogFigurebed/master/img/image-20200829164753764.png" srcset="/img/loading.gif" alt="视锥体立体图（手拙，大家凑活看吧）"></p><p>好啦，主要参数设置完了，然后呢？如何通过这四个参数来计算视锥体六个面呢？（下图是一张侧视图，沿着上图中红轴相反方向观察）</p><p><img src="https://raw.githubusercontent.com/AOldDriverA/BlogFigurebed/master/img/image-20200829212421668.png" srcset="/img/loading.gif" alt="尽力了，凑活看吧，下次换个好的画图软件"></p><pre><code class="hljs javascript"><span class="hljs-comment">// 结合图看应该会好一些（两个图搞了我半天）</span><span class="hljs-comment">// f.top就是近裁剪面的半高，结合图，top / near = tan(α1), 所以top = near * tan(α1)</span>f.top = frustum.near * <span class="hljs-built_in">Math</span>.tan(<span class="hljs-number">0.5</span> * frustum._fovy);f.bottom = -f.top;<span class="hljs-comment">// aspectRatio = clientWidth / clientHeight = top / right, 所以right = top / aspectRatio</span>f.right = frustum.aspectRatio * f.top;f.left = -f.right;f.near = frustum.near;f.far = frustum.far;<span class="hljs-comment">// xOffset和yOffset主要是视点（上图的A点，上上图的E点，很抱歉两张图顶点位置没能对应和统一）</span><span class="hljs-comment">// 相对于原点的偏移，这里为了计算方便，默认偏移生在Z轴垂直的xy平面上，z值都一样没变化（这里是0）</span><span class="hljs-comment">// 所以near和far没变化，省略不写</span>f.right += frustum.xOffset;f.left += frustum.xOffset;f.top += frustum.yOffset;f.bottom += frustum.yOffset;</code></pre><p>好了，该有的都有了，下面开始干正事了：构建裁剪面，再手拙来张图解释一下。</p><p>相机的<code>direction</code>对应视锥体坐标系中的<strong>绿轴</strong>向量，<code>right</code>对应视锥体坐标系中的<strong>红轴</strong>向量，<code>up</code>对应视锥体坐标系中的<strong>蓝轴</strong>向量，这里绿、红、蓝轴正好和球心所在的笛卡尔坐标系中的绿、红、蓝轴平行了，正常情况下两者坐标系很可能不一，需要做旋转平移变换；</p><p>浅绿色四棱锥代表视锥体，<em>CDEF</em>代表<strong>近平面</strong>，<em>H</em>代表近平面<strong>左边中点</strong>，<em>G</em>（四棱锥顶点）代表<strong>相机视点</strong>，蓝色星球代表地球，视锥体的绿轴与近平面的交点<em>O</em>就是近平面中点，紫色线为左平面法向量（图只是示例，实际法向量指向视锥体内部，下面有详细说明）；</p><p>球心所在的原点为笛卡尔三维坐标系，视锥体的绿轴与近平面的交点O就是近平面中点；</p><p><img src="https://raw.githubusercontent.com/AOldDriverA/BlogFigurebed/master/img/image-20200902084709681.png" srcset="/img/loading.gif" alt="凑活看吧，没艺术天分的"></p><pre><code class="hljs javascript">PerspectiveOffCenterFrustum.prototype.computeCullingVolume = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">position, direction, up</span>) </span>&#123;  <span class="hljs-keyword">var</span> planes = <span class="hljs-keyword">this</span>._cullingVolume.planes;  <span class="hljs-comment">// 将上面求得的一大坨丢到下面</span>  <span class="hljs-keyword">var</span> t = <span class="hljs-keyword">this</span>.top, b = <span class="hljs-keyword">this</span>.bottom, r = <span class="hljs-keyword">this</span>.right, l = <span class="hljs-keyword">this</span>.left, n = <span class="hljs-keyword">this</span>.near, f = <span class="hljs-keyword">this</span>.far;  <span class="hljs-comment">// 前向与上方向叉乘得右方向，direction和up包括right都在rectangleCameraPosition3D中进行了初始化</span>  <span class="hljs-comment">// direction其实就是将经纬度转为笛卡尔三维坐标并进行了归一化就变成了向量（取反，因为从相机到球心）</span>  <span class="hljs-comment">// right是direction和笛卡尔Z轴叉乘结果，up是right和direction叉乘结果，这里又对right进行了更新</span>  <span class="hljs-keyword">var</span> right = Cartesian3.cross(direction, up, getPlanesRight);  <span class="hljs-keyword">var</span> nearCenter = getPlanesNearCenter;    <span class="hljs-comment">// 近平面，由方向和距离构成</span>  Cartesian3.multiplyByScalar(direction, n, nearCenter);<span class="hljs-comment">// 方向向量*近平面距离得到视点指向近平面中心点的向量（其实是与视点的坐标差）</span>  Cartesian3.add(position, nearCenter, nearCenter);   <span class="hljs-comment">// 得到近平面中心点三维坐标</span>  <span class="hljs-keyword">var</span> farCenter = getPlanesFarCenter; <span class="hljs-comment">// 远平面，同上</span>  Cartesian3.multiplyByScalar(direction, f, farCenter);  Cartesian3.add(position, farCenter, farCenter);  <span class="hljs-keyword">var</span> normal = getPlanesNormal;  <span class="hljs-comment">// right是上面计算的视锥体右方向，这里*l就计算出了左裁剪面的向量（不是左裁剪面的法向量）</span>  Cartesian3.multiplyByScalar(right, l, normal);  <span class="hljs-comment">// 近裁剪面左边中点三维坐标</span>  Cartesian3.add(nearCenter, normal, normal);  <span class="hljs-comment">// 相机位置G指向左边中点H的向量GH，也就是说normal = GH</span>  Cartesian3.subtract(normal, position, normal);  <span class="hljs-comment">// 赶紧归一化刚刚计算出来的热乎乎向量</span>  Cartesian3.normalize(normal, normal);  <span class="hljs-comment">// 相机上方向向量up也平行于左平面内，大家可以想想是这么回事。因为左平面应该要平行于上方向，这样近裁剪面才能是个矩形而不是菱形</span>  <span class="hljs-comment">// 大家感觉抽象可以看看上张图，近平面左边EF线平行于视锥体的up轴</span>  <span class="hljs-comment">// 左裁剪面法向量normal = GH x up</span>  <span class="hljs-comment">// 惊了！！（类似右手点则那样）这里左平面法向量竟然指向视锥体内部！！！！！！！！</span>  Cartesian3.cross(normal, up, normal);   <span class="hljs-comment">// 再归一化，OVER！回头看，其实挺简单的就是基础的向量计算</span>  Cartesian3.normalize(normal, normal);  <span class="hljs-keyword">var</span> plane = planes[<span class="hljs-number">0</span>];  plane.x = normal.x; <span class="hljs-comment">// 将左裁剪面法向量的各分量存起来</span>  plane.y = normal.y;  plane.z = normal.z;  <span class="hljs-comment">// 相机点的位置本质也是个向量，从球心指向相机，此处求得是相机距离在左裁剪面法向量上的投影并取反</span>  <span class="hljs-comment">// 得到了左裁剪面与球心的距离！没想到距离用的是与球心的距离！（因为裁剪面法向量指向视锥体内部，所以取反为正）</span>  plane.w = -Cartesian3.dot(normal, position);  <span class="hljs-comment">// 同样的操作得到右裁剪面</span>......  <span class="hljs-comment">// 将right换成up，继续换汤不换药之旅，求出上裁剪面和底裁剪面的表达形式</span>  ......    <span class="hljs-comment">// 近裁剪面和远裁剪面法向量都是相机的方向direction，距离就是球心到裁剪面中点距离也就是中点向量的模长</span>  <span class="hljs-comment">// 由direction点乘nearCenter或farCenter得到</span>  plane = planes[<span class="hljs-number">4</span>];  plane.x = direction.x;  plane.y = direction.y;  plane.z = direction.z;  plane.w = -Cartesian3.dot(direction, nearCenter);<span class="hljs-comment">// 六个plane都赋值完了，就可以返回cullingVolume了</span>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._cullingVolume;&#125;;</code></pre><p>裁剪面构建好了，下面就开始判断物体和视锥体的空间关系了，进而判断物体是否在视锥体内了（就是物体和裁剪面的关系）。前面啰嗦了一大堆（主要是我想事无巨细的回顾一下），终于要进入这篇文章的正题了，开熏！</p><p>视锥体裁剪是可视化最基础的功能之一，排除掉无关的七大姑八大姨，渲染一个物体最快的方式就是不渲染它，那么它是如何做到的呢？这里再简要说一下视域体裁剪之前的流程，当做一个背景吧。详细流程还是请看法克鸡丝大神的<a href="https://www.cnblogs.com/fuckgiser/p/5772077.html" target="_blank" rel="noopener">Cesium原理篇2</a>和<a href="https://www.cnblogs.com/fuckgiser/p/5883227.html" target="_blank" rel="noopener">3</a>。现在的遥感影像都是LOD加载，你看全球的时候，遥感影像用粗分辨率，随着你滚轮滚动视野拉近，影像逐渐被更精细的影像所代替（人们一直都很讨厌马赛克的，至少我是，嘿嘿），Cesium中，遥感影像的框架是矩形<em>QuadtreePrimitive</em>(具体的实现单元是GlobeSurfaceTileProvider)，（瓦片中可以请求地形等作为骨架，然后贴上影像，产生了高低不平的感觉，这里不做详述，有机会再说），如何判断你需要更精细的影像呢？就是判断这个矩形有没有进行四叉树剖分，如果进行了四叉树剖分，根据剖分后子网格的行列号信息（经纬网格剖分规则固定且简单，所以约定俗称，可以通过行列号确定范围，去服务端请求影像）。这里隐藏了涉及细分阈值的问题，cesium使用的是简单而又有效的算法：像素误差。它会去影像发布的服务那里（不管哪里，反正有规范）获取每一层级对应的一个像素分辨率，然后根据相机与球面的实时距离，判断误差是否满足要求，如果大于一个像素了，就再请求更精细的，换句话说，四叉树就开始剖分了。剖分时就要对四个子孩子进行可见性判断，这时也用到了视锥体进行剪枝。</p><h3 id="视锥体如何求交？"><a href="#视锥体如何求交？" class="headerlink" title="视锥体如何求交？"></a>视锥体如何求交？</h3><h4 id="computeTileVisibility"><a href="#computeTileVisibility" class="headerlink" title="computeTileVisibility"></a>computeTileVisibility</h4><p>它定义在  QuadtreePrimitive中的一个方法，但因为QuadtreePimitive是个虚类，所以真正实现是在GlobeSurfaceTileProvider中。下面跟着代码走一遍。</p><pre><code class="hljs js">GlobeSurfaceTileProvider.prototype.computeTileVisibility = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">tile, frameState, occluders</span>) </span>&#123;  <span class="hljs-comment">// 判断雾,先用雾特效才进行过滤一波</span>  <span class="hljs-keyword">if</span> (frameState.fog.enabled) &#123;...&#125;  <span class="hljs-comment">// 视椎体六个面</span>  <span class="hljs-keyword">var</span> cullingVolume = frameState.cullingVolume;  <span class="hljs-comment">// 网格包围盒（比包围球和轴向包围盒更紧当然速度比boundingSphere略慢）</span>  <span class="hljs-keyword">var</span> boundingVolume = surfaceTile.orientedBoundingBox;  <span class="hljs-comment">// 判断是否相交的函数！！！！！</span>  <span class="hljs-keyword">var</span> intersection = cullingVolume.computeVisibility(boundingVolume);  <span class="hljs-keyword">if</span> (intersection === Intersect.OUTSIDE) &#123;    <span class="hljs-keyword">return</span> Visibility.NONE;  &#125;  <span class="hljs-comment">// EllipsoidalOccluder 确定其他物体是可见的还是隐藏在由椭球体和摄像机位置定义的可见视界后面。假定椭球位于坐标系的原点。这个类使用Horizon截取博客文章中描述的算法。</span>  <span class="hljs-keyword">var</span> ortho3D = frameState.mode === SceneMode.SCENE3D &amp;&amp; frameState.camera.frustum <span class="hljs-keyword">instanceof</span> OrthographicFrustum;  <span class="hljs-keyword">if</span> (frameState.mode === SceneMode.SCENE3D &amp;&amp; !ortho3D &amp;&amp; defined(occluders)) &#123;  <span class="hljs-comment">// 如果定义了遮挡物</span>    <span class="hljs-keyword">var</span> occludeePointInScaledSpace = surfaceTile.occludeePointInScaledSpace;    <span class="hljs-comment">// 测试可见性的点，椭球上被遮挡的点，位于水平线就不渲染</span>    <span class="hljs-keyword">if</span> (!defined(occludeePointInScaledSpace)) &#123;      <span class="hljs-keyword">return</span> intersection;    &#125;    <span class="hljs-comment">// 就是水平线下不绘制，测试遮不遮挡。下面的方法就是博客中介绍的方法，输入的是一个点的坐标，所以我怀疑在没有高度的格网中作用有限</span>    <span class="hljs-keyword">if</span> (occluders.ellipsoid.isScaledSpacePointVisible(occludeePointInScaledSpace)) &#123;<span class="hljs-comment">// 确定在椭球面缩放空间中表示的点是否被遮挡器遮挡。</span>      <span class="hljs-keyword">return</span> intersection;                                                        <span class="hljs-comment">// 要将与椭球体对齐的直角坐标系中的X、Y、Z坐标转换为缩放空间，请调用椭球体# transformpositiontocaledspace。</span>    &#125;    <span class="hljs-keyword">return</span> Visibility.NONE;  &#125;  <span class="hljs-keyword">return</span> intersection;&#125;;</code></pre><p>展开上段代码中第10行<code>cullingVolume.computeVisibility(boundingVolume)</code>函数，里面调用的是包围球与视锥体平面之间的包含关系判断</p><p><img src="https://raw.githubusercontent.com/AOldDriverA/BlogFigurebed/master/img/image-20200902101446819.png" srcset="/img/loading.gif" alt="包围球与视锥体相交判断简化图"></p><p>如上丑图所示，大家咀嚼一下</p><pre><code class="hljs javascript">BoundingSphere.intersectPlane = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">sphere, plane</span>) </span>&#123;  <span class="hljs-keyword">var</span> center = sphere.center; <span class="hljs-keyword">var</span> radius = sphere.radius; <span class="hljs-keyword">var</span> normal = plane.normal;  <span class="hljs-comment">// Cartesian3.dot(normal, center)是计算包围球球心到裁剪面的距离HA。因为center向量和normal向量（左裁剪面法向量normal指向视锥体内部）夹角大于180度（如上图所示），所以值为负，distanceToPlane = HA + AI = -AH + AI；</span>  <span class="hljs-keyword">var</span> distanceToPlane = Cartesian3.dot(normal, center) + plane.distance; <span class="hljs-comment">// -AH + AI；</span>  <span class="hljs-keyword">if</span> (distanceToPlane &lt; -radius) &#123; <span class="hljs-comment">// -AH + AI &lt; -R -&gt; AI + R &lt; AH 所以包围球在平面外</span>    <span class="hljs-keyword">return</span> Intersect.OUTSIDE;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (distanceToPlane &lt; radius) &#123; <span class="hljs-comment">// -AH + AI &lt; R -&gt; -R &lt;= AI - AH &lt; R 所以包围球与平面相交</span>    <span class="hljs-keyword">return</span> Intersect.INTERSECTING;  &#125;<span class="hljs-comment">// -AH + AI &gt; R -&gt; AI - AH &gt; R 最后一种情况，包围球在平面内</span>  <span class="hljs-keyword">return</span> Intersect.INSIDE;&#125;;</code></pre><p>包围盒与视域体相交的情况我不想画图了，空口说白话看看大家能否听懂</p><pre><code class="hljs javascript">OrientedBoundingBox.intersectPlane = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">box, plane</span>) </span>&#123;  <span class="hljs-keyword">var</span> center = box.center; <span class="hljs-keyword">var</span> normal = plane.normal; <span class="hljs-keyword">var</span> halfAxes = box.halfAxes;  <span class="hljs-keyword">var</span> normalX = normal.x, normalY = normal.y, normalZ = normal.z;  <span class="hljs-keyword">var</span> radEffective = <span class="hljs-built_in">Math</span>.abs(normalX * halfAxes[Matrix3.COLUMN0ROW0] + normalY * halfAxes[Matrix3.COLUMN0ROW1] + normalZ * halfAxes[Matrix3.COLUMN0ROW2]) +      <span class="hljs-built_in">Math</span>.abs(normalX * halfAxes[Matrix3.COLUMN1ROW0] + normalY * halfAxes[Matrix3.COLUMN1ROW1] + normalZ * halfAxes[Matrix3.COLUMN1ROW2]) +      <span class="hljs-built_in">Math</span>.abs(normalX * halfAxes[Matrix3.COLUMN2ROW0] + normalY * halfAxes[Matrix3.COLUMN2ROW1] + normalZ * halfAxes[Matrix3.COLUMN2ROW2]);  <span class="hljs-keyword">var</span> distanceToPlane = Cartesian3.dot(normal, center) + plane.distance;  <span class="hljs-keyword">if</span> (distanceToPlane &lt;= -radEffective) &#123;    <span class="hljs-comment">// The entire box is on the negative side of the plane normal</span>    <span class="hljs-keyword">return</span> Intersect.OUTSIDE;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (distanceToPlane &gt;= radEffective) &#123;    <span class="hljs-comment">// The entire box is on the positive side of the plane normal</span>    <span class="hljs-keyword">return</span> Intersect.INSIDE;  &#125;  <span class="hljs-keyword">return</span> Intersect.INTERSECTING;&#125;;</code></pre><p>上面分情况判断完了每一个面的情况，下面来看看函数是怎么被调用的</p><pre><code class="hljs javascript">CullingVolume.prototype.computeVisibility = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">boundingVolume</span>) </span>&#123;  <span class="hljs-keyword">var</span> planes = <span class="hljs-keyword">this</span>.planes;<span class="hljs-comment">// 视锥体的那六个面</span>  <span class="hljs-keyword">var</span> intersecting = <span class="hljs-literal">false</span>;<span class="hljs-comment">// 默认相离</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k = <span class="hljs-number">0</span>, len = planes.length; k &lt; len; ++k) &#123;    <span class="hljs-comment">// 以此判断六个面与包围盒或包围球的相交情况</span>    <span class="hljs-keyword">var</span> result = boundingVolume.intersectPlane(Plane.fromCartesian4(planes[k], scratchPlane));    <span class="hljs-keyword">if</span> (result === Intersect.OUTSIDE) &#123;<span class="hljs-comment">// 包围球（盒）在任何一个平面的外部肯定也在整个视锥体的外部</span>      <span class="hljs-keyword">return</span> Intersect.OUTSIDE; <span class="hljs-comment">// 这种确定相离的情况就可以直接返回了</span>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result === Intersect.INTERSECTING) &#123;      intersecting = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 判断是否相交 </span>    &#125;  &#125;<span class="hljs-comment">// 但凡有一个面相交，就可以确定是相交。六个面都没相交（当然，走到这一步也不可能相离）就说明是包含</span>  <span class="hljs-keyword">return</span> intersecting ? Intersect.INTERSECTING : Intersect.INSIDE;&#125;;</code></pre><p>下面到了我项目中的实际应用了。原理解释清楚了，应用就很简单了，cesium都封装好了函数，直接调用就行</p><pre><code class="hljs javascript"><span class="hljs-comment">// 构建格网包围盒(这里是包围球)，这样才能与视锥体进行裁剪判断</span>tile.boundingBox = Cesium.BoundingSphere.fromRectangle3D(rectangle, ellipsoid, <span class="hljs-number">0</span>, boundingBox);<span class="hljs-comment">// 获取相机的视锥体</span><span class="hljs-keyword">var</span> cullingVolume = camera.cullingVolume;<span class="hljs-comment">// 判断视椎体与格网包围盒是否相交(上面的那个函数)，返回intersection：0表示相交，-1表示相离，1表示包含</span><span class="hljs-keyword">var</span> intersection = cullingVolume.computeVisibility(tile.boundingBox);</code></pre><p>对于相交或包含在视锥体内的物体，还需要进行进一步的判断，因为点可能在地球背面</p><p><img src="https://raw.githubusercontent.com/AOldDriverA/BlogFigurebed/master/img/image-20200902163436232.png" srcset="/img/loading.gif" alt="image-20200902163436232"></p><p>如上图所示，橙色四棱锥表示视锥体，蓝色星球表示地球，点H（紫色）和点I（红色）都在视锥体内，但点H在近可见面，点I在地球背面，屏幕中只能看到点H，但点I也进行了保留，所以需要将点I给删除，这就用到了背面剔除。</p><h3 id="背面剔除"><a href="#背面剔除" class="headerlink" title="背面剔除"></a>背面剔除</h3><h4 id="cesium是如何做到高效率的呢———向量计算"><a href="#cesium是如何做到高效率的呢———向量计算" class="headerlink" title="cesium是如何做到高效率的呢———向量计算"></a>cesium是如何做到高效率的呢———向量计算</h4><p>借用Cesium<a href="https://cesium.com/blog/2013/04/25/horizon-culling/" target="_blank" rel="noopener">技术博客</a>中的一张说明图片，该博客对背面剔除等技术进行了介绍，英语不给力的话可以搭配有道食用，下面的内容也是对该博客的内容复现和一点点的总结。</p><p>点V表示视点；VC表示相机direction；VH是相机视域体一个裁剪面，这里姑且当做三视图里的右视图吧，这样VH代表的线其实就是视锥体中的Top面（上面）；C表示球心；黑线HP表示视线中的地平线，也就是说，点V到点HP之间的物体是可见的，HP之后的物体是不可见的，就像你看不到海平面后面的战列舰一样；T表示空间中的任意一点</p><p><img src="https://raw.githubusercontent.com/AOldDriverA/BlogFigurebed/master/img/HorizonCullingCone.png" srcset="/img/loading.gif" alt="img"></p><p>Cesium这里做了一个有趣的背景：VH总是和球面相切的，这样VCH就是直角三角形了，满足关系$||\vec{VH}||^2+||\vec{HC}||^2=||\vec{VC}||^2$，然后让地球半径R(CH）等于1，然后其他值比如VC和VH转为R的倍数表达，所以$||\vec{VH}||^2=||\vec{VC}||^2 - 1$。</p><p>VHC和HPC是相似三角形</p><script type="math/tex; mode=display">\frac{||\vec{CP}||}{||\vec{CH}||}=\frac{||\vec{CH}||}{||\vec{CV}||}</script><script type="math/tex; mode=display">\frac{||\vec{CP}||}{1}=\frac{1}{||\vec{CV}||};</script><script type="math/tex; mode=display">||\vec{VP}|| = ||\vec{CV}||-\frac{1}{||\vec{CV}||};</script><h4 id="如何判断点是在地平线前面还是后面呢？"><a href="#如何判断点是在地平线前面还是后面呢？" class="headerlink" title="如何判断点是在地平线前面还是后面呢？"></a>如何判断点是在地平线前面还是后面呢？</h4><p>VQ &lt; VP，则点在地平线（HP所在直线表示）前，VQ &gt; VP则点在地平线后，VQ是VT在VC上的投影，所以当VQ &gt; VP时，应该被裁剪掉，即：</p><script type="math/tex; mode=display">\frac{\vec{VC}}{||\vec{VC}||}\cdot\vec{VT}>||\vec{CV}||-\frac{1}{||\vec{CV}||}</script><p>这里解释一下，$VQ=\frac{\vec{VC}}{||\vec{VC}||}\cdot\vec{VT}$,是因为a点乘b，当a和b为单位向量时，结果为向量夹角的余弦值；当a为单位向量时，结果为b在a上的投影；当a和b都不为单位向量时，结果为a、b的模长乘以夹角的余弦值。这里VQ是VT在VC上的投影，所以VC需要为单位向量。继续化简，两边同时乘以||<em>CV</em>||所以最终结果为(只要公式成立，那么点就在地平线后或者说地球背面，需要被裁掉)：</p><script type="math/tex; mode=display">\vec{VC}\cdot\vec{VT}>||\vec{CV}||^2-1</script><h4 id="如何快速的判断点T是否在视锥体内呢？"><a href="#如何快速的判断点T是否在视锥体内呢？" class="headerlink" title="如何快速的判断点T是否在视锥体内呢？"></a>如何快速的判断点T是否在视锥体内呢？</h4><p>之前采用的是物体包围盒（或球），因为之前的物体有体积。这里只判断点的话可以通过判断VT与VC的夹角和VH与VC的夹角，如果在视锥体<strong>外</strong>，那么</p><script type="math/tex; mode=display">\angle β>\angle α</script><script type="math/tex; mode=display">cos(β)>cos(α)->cos(β)>\frac{||\vec{VH}||}{||\vec{VC}||}</script><script type="math/tex; mode=display">cos(β)=\frac{\vec{VT}\cdot\vec{VC}}{||\vec{VT}||\cdot||\vec{VC}||}</script><script type="math/tex; mode=display">\frac{\vec{VT}\cdot\vec{VC}}{||\vec{VT}||\cdot||\vec{VC}||}>\frac{||\vec{VH}||}{||\vec{VC}||}</script><script type="math/tex; mode=display">\frac{\vec{VT}\cdot\vec{VC}}{||\vec{VT}||}>{||\vec{VH}||}</script><script type="math/tex; mode=display">\frac{(\vec{VT}\cdot\vec{VC})^2}{||\vec{VT}||^2}>{||\vec{VH}||^2};结合上面的||\vec{VH}||^2=||\vec{VC}||^2 - 1</script><script type="math/tex; mode=display">\frac{(\vec{VT}\cdot\vec{VC})^2}{||\vec{VT}||^2}>||\vec{VC}||^2 - 1</script><p>好了，至此重要技术已经叙述完毕，这个公式怎么用呢？其实就是先将球面上的点归一化为1（因为上面的公式地球半径默认为1，也就是CH为1），然后再按照比例对视点V和判断点T进行处理，cesium也提供了椭球面到球面的转换来让你可以放心大胆的使用此方法。</p><p>等等，这个是判断点是否在视锥体内，因为点忽略的体积，所以就忽略了包围盒，但我一个有体积的物体怎么判断？</p><p><img src="https://raw.githubusercontent.com/AOldDriverA/BlogFigurebed/master/img/image-20200902202353405.png" srcset="/img/loading.gif" alt="image-20200902202353405"></p><p>找一个<strong>特征点</strong>！通过判断该物体特征点的可不可见是否在地球背面来决定该物体是否要剔除。Cesium在<a href="https://cesium.com/blog/2013/05/09/computing-the-horizon-occlusion-point/" target="_blank" rel="noopener">这篇</a>文章中讲了如何确定特征点，我遇到的是对自己绘制的网格进行可见性分析，情况比Cesium的简单，所以我自己设计了两种方法还有一张图。上面这张图是来解释第一个方法特征点的，圆弧CD表示紧贴球面的网格，然后过C和D点两条切线相较于E点，这两天切线模拟与地球相切的视线，此时刚好能看到E，如果C点往左边移动到G或者D点往下移动到H，C和D的交点就在I点，这是是看不到E点的（视点在球体左边或者下边），很显然也就看不到网格。如何计算E点呢？</p><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (intersection == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 方法一，给网格找一个特征点（上图的E点就是特征点）</span>  <span class="hljs-comment">// 计算AE与AC（也就是地球半径的比值）作为AE向量缩放的因子，也就是factor</span>  <span class="hljs-keyword">var</span> factor = <span class="hljs-number">1</span> / <span class="hljs-built_in">Math</span>.cos((tile.north - tile.south) * PI / <span class="hljs-number">360</span>);  <span class="hljs-comment">// AE = factor * AF。这里AF是三维笛卡尔坐标，你也可以按照惯例把他当成变量，乘系数就变成了E点坐标（或者球心指向E的向量）</span>  <span class="hljs-keyword">var</span> point0 = Cesium.Cartesian3.multiplyByScalar(tile.center, factor, unUsedPoint);  <span class="hljs-comment">// 将该投影到球面上，并没有丧失其他信息</span>  <span class="hljs-keyword">var</span> scaledSpacePoint0 = ellipsoid.transformPositionToScaledSpace(point0, scratchCartesian);  <span class="hljs-comment">// 判断点是否在视锥体内并且在地平线之前（就是上面讲的视域体裁剪和背面剔除）</span>  ifPointVisible = occluder.isScaledSpacePointVisible(scaledSpacePoint0);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (intersection == <span class="hljs-number">1</span> &amp;&amp; tile.level &lt; <span class="hljs-number">3</span>) &#123;  <span class="hljs-comment">// 方法二，遍历网格四个顶点，任何一个满足既在视锥体内又在地平线之前，则该网格保留。。（没错，就是这么暴力这么笨）</span>  <span class="hljs-keyword">var</span> points = Cesium.Cartesian3.fromRadiansArray([rectangle.west, rectangle.north, rectangle.west, rectangle.south, rectangle.east, rectangle.south, rectangle.east, rectangle.north]);  <span class="hljs-keyword">if</span> (occluder.isScaledSpacePointVisible(ellipsoid.transformPositionToScaledSpace(points[<span class="hljs-number">0</span>]))) &#123;    ifPointVisible = <span class="hljs-literal">true</span>;  &#125;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (occluder.isScaledSpacePointVisible(ellipsoid.transformPositionToScaledSpace(points[<span class="hljs-number">1</span>]))) &#123;    ......  &#125;    ......&#125;</code></pre><p>主要的技术到现在真的说完了，下面开始胡扯了，欢迎各位大佬批评指正。</p><p>但有两个小问题，<strong>一个是Cesium默认视线和球面相切</strong>，但当你不断拉近距离而视场角fovy又是恒定的，所以真正的视域体肯定不会一直相切（且是只有一瞬间是真正相切的），但如果仍然按照相切的，其实会造成部分冗余，如下图所示</p><p><img src="https://raw.githubusercontent.com/AOldDriverA/BlogFigurebed/master/img/image-20200902203952978.png" srcset="/img/loading.gif" alt="image-20200902203952978"></p><p>一开始视点在C，这时两条紫色线代表视锥体，正好和球体相切，判断一切正常，但你视角拉近与球面距离接近到点D，这时你正常的视角是绿色的线，直接穿过了球体，但Cesium的这个方法判断时仍然采用相切的背景条件，也就是红色线与地球相切，两条红色线夹角内的区域都算在可视域内，比如JH和GI两条弧在D真正的可视域内是看不到的，但却得到了保留，造成了数据冗余。</p><p>这其实是个痛点，因为你在球面上很难找到合适的边界值（如途中的 H和G），裁剪面与球面相交的线是弧线，难以找到特征点（这段是我瞎猜的，后面有时间会看看）。我在写细分阈值时也遇到了这种类似的问题，判断条件写死了（判断条件也是默认相切），但实际却又是灵活变化的（不过那个被我很好的解决了）。</p><p><strong>第二个问题是特征点问题</strong>。Cesium判断物体与视锥体空间关系前面也说了三种：相交、相离、包含。这个包含比较特殊，指的是<strong>视锥体</strong>包含<strong>物体</strong>。但当物体很大视锥体很小时，就变成了<strong>物体</strong>包含<strong>视锥体</strong>，这种情况Cesium是<strong>没考虑</strong>的！尤其是物体很大视锥体很小时，你选取的特征点没被包含在视锥体内，就会被判断不可见。这是就会发生奇怪的现象：距离地表非常近（几米内）时，突然间所有网格都消失了。没办法，项目着急验收，于是乎就改了Cesium的源码，在isScaledSpacePointVisible的基础上又给 EllipsoidalOccluder添加了isScaledSpacePointVisibleAtCloseRang方法，在里面手动改变了当距离过近时的地平线距离，后面有时间还是得添加一个更灵活更好的解决方法。好啦，聊了这么多不知道有多少消化不良的。</p><p>今天是9月2日，补了一个月终于搞完了。下面要填光线追踪的坑了，正好再复习一下。不得不提，今天NVIDIA发布了3090显卡，支持光线追踪，等回来找到工作一定买一个玩一玩。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>粒子模拟</title>
    <link href="/2020/06/07/%E7%B2%92%E5%AD%90%E6%A8%A1%E6%8B%9F/"/>
    <url>/2020/06/07/%E7%B2%92%E5%AD%90%E6%A8%A1%E6%8B%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="粒子模拟：以Cesium中的风场为例"><a href="#粒子模拟：以Cesium中的风场为例" class="headerlink" title="粒子模拟：以Cesium中的风场为例"></a><center>粒子模拟：以Cesium中的风场为例<center></h2><p>闫令琪大神在GAMES101课程中提到过，粒子模拟需要考虑的一下五个问题（或者说步骤）：</p><p>Particles Simulation</p><ul><li>[If needed] Create new particles</li><li>Calculate forces on each particles</li><li>Update each particle’s position and velocity</li><li>[If needed] Remove dead particles</li><li>Render particles</li></ul><p>实际的渲染过程一般分为粒子运动模拟和渲染两部分。下面以Cesium为平台模拟风场，用到的技术主要是WebGL中的渲染到纹理。</p><p>很幸运Cesium的技术博客有关于风场的<a href="https://cesium.com/blog/2019/04/29/gpu-powered-wind/" target="_blank" rel="noopener">Demo</a>可以作为学习的对象，毕竟代码是公开的，知识是自己的，学到就是赚到。下文以该Demo为例进行介绍（个人只对Demo做了小幅度的修改和优化，原Demo基本没有注释，吃到嘴里咽不下去的那种干货，所以又对代码进行了注释，这里主要讲解思想）。</p><p>阅读源码首先一定要提纲挈领和把握主体，千万不要刚开始啥都不知道就细扣，否则只能想我一样浪费了大量的时间。有了主体脉络再进行理解，知识就不在碎片化，这篇文章的主要用意也是对学到的进行总结。</p><p>再啰嗦一句，我最开始学习粒子模拟风场是学习<a href="https://mp.weixin.qq.com/s?__biz=MzU1ODcyMjEwOA==&amp;mid=2247484268&amp;idx=1&amp;sn=861480d7108f70a2fd16000df4df2db1&amp;chksm=fc237e3fcb54f72904a9cd57a3c2bf325e30a00de614ec3145dcb1f0310e7c0f9362d4f00742&amp;token=1964897234&amp;lang=zh_CN#rd" target="_blank" rel="noopener">giserYZ2SS</a>大佬的<a href="https://github.com/YanzheZhang/Cesium.HPUZYZ.Demo" target="_blank" rel="noopener">Demo</a>，很不错的入门（基本思想非常干练，几个小时就能搞定），基本就涵盖了上面的五个步骤，但性能有些问题，主要是粒子运动模拟这部分使用CPU进行计算的，效率较低，可以使用WebGL的渲染到纹理方法，就是将<strong>数据</strong>保存到<strong>纹理</strong>（帧缓冲区的<strong>纹理对象</strong>不会被渲染出来，可以当做是中间过程的一个缓存区），然后对纹理对象中的纹理进行操作（实质是对纹理中的数据），最后渲染到颜色缓冲区在屏幕中展示出来。</p><h3 id="第一步：如何创建新的粒子"><a href="#第一步：如何创建新的粒子" class="headerlink" title="第一步：如何创建新的粒子"></a>第一步：如何创建新的粒子</h3><ol><li>确定粒子数量</li></ol><p>创建粒子最终要存储到纹理中，也就是说一个粒子对应纹理中的一个纹素（可以当成是屏幕中的像素），所以粒子的数量就是纹理中纹素的数量就是纹理的长x宽，这里假设纹理是正方形，长宽为<em>particlesTextureSize</em>个纹素，则可以存储的粒子最大数量：<em>maxParticles</em>=particlesTextureSize^2。</p><ol><li>生成（在屏幕中均匀分布的）随机粒子（坐标）</li></ol><pre><code class="hljs js">DataProcess.randomizeParticles = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">maxParticles, viewerParameters</span>) </span>&#123;  <span class="hljs-comment">// 粒子用纹理进行存储就是将x，y，z，w等信息存储到纹理的RGBA分量上</span>  <span class="hljs-comment">// 所以类型化数组array.size（）为：4 * maxParticles个</span>  <span class="hljs-keyword">var</span> array = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Float32Array</span>(<span class="hljs-number">4</span> * maxParticles);  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; maxParticles; i++) &#123;    <span class="hljs-comment">// 依次随机生成经度、纬度，存储到对应的R、G分量上，其余分量取0.0</span>    <span class="hljs-comment">// Cesium自带的randomBetween函数最终调用的是MersenneTwister伪随机数生成方法</span>    array[<span class="hljs-number">4</span> * i] = Cesium.Math.randomBetween(viewerParameters.lonRange.x, viewerParameters.lonRange.y);    array[<span class="hljs-number">4</span> * i + <span class="hljs-number">1</span>] = Cesium.Math.randomBetween(viewerParameters.latRange.x, viewerParameters.latRange.y);    array[<span class="hljs-number">4</span> * i + <span class="hljs-number">2</span>] = <span class="hljs-number">0.0</span>;    array[<span class="hljs-number">4</span> * i + <span class="hljs-number">3</span>] = <span class="hljs-number">0.0</span>;  &#125;  <span class="hljs-keyword">return</span> array;&#125;</code></pre><p>DataProcess类主要负责场景中用到的所有数据的加载和解析，属于预处理部分，所以randomizeParticles为它的属性。viewerParameters是Cesium中和视场有关的数据，这里为当前屏幕中出现的球体上的经纬度范围（可能表述的不是很清楚，专业一点就是视锥体在球面上投影区域的经纬度范围），主要是为了随机生成的粒子尽量均匀平铺同时所有数据都在视锥体内可见，避免了产生冗余数据。</p><ol><li>创建存储粒子的纹理</li></ol><pre><code class="hljs js">createParticlesTextures(context, userInput, viewerParameters) &#123;  <span class="hljs-comment">// 创建纹理所需的参数</span>  <span class="hljs-keyword">let</span> particlesTextureOptions = &#123;    context: context,    <span class="hljs-comment">// 是不是很眼熟？确定粒子数量时用到的参数，就是纹理长宽的文素数</span>    width: userInput.particlesTextureSize,    height: userInput.particlesTextureSize,    <span class="hljs-comment">// 一个纹理表示一个向量的齐次坐标，包含四个参数，需要用RGBA来对应存储</span>    pixelFormat: Cesium.PixelFormat.RGBA,    pixelDatatype: Cesium.PixelDatatype.FLOAT  &#125;;    <span class="hljs-comment">// 生成随机粒子点坐标（没错，上一步的函数就是在这里用到的）</span>  <span class="hljs-keyword">var</span> particlesArray = DataProcess.randomizeParticles(userInput.maxParticles, viewerParameters)  <span class="hljs-comment">// 一口气创建n多个纹理</span>  <span class="hljs-keyword">this</span>.particlesTextures = &#123;    <span class="hljs-comment">// 创建值为0的纹理</span>    particlesWind: Util.createTexture(particlesTextureOptions),    <span class="hljs-comment">// 当前粒子坐标纹理</span>    currentParticlesPosition: Util.createTexture(particlesTextureOptions, particlesArray),    <span class="hljs-comment">// 下一步的坐标纹理</span>    nextParticlesPosition: Util.createTexture(particlesTextureOptions, particlesArray),    <span class="hljs-comment">// 当前粒子速度</span>    currentParticlesSpeed: Util.createTexture(particlesTextureOptions, zeroArray),    <span class="hljs-comment">// 下一步的粒子速度</span>    nextParticlesSpeed: Util.createTexture(particlesTextureOptions, zeroArray)  &#125;;&#125;</code></pre><p>在this.particlesTextures中创建五个下面会用到的纹理。</p><p>particlesArray就是随机生成的粒子经纬度坐标，四个一组，根据这些经纬度坐标去风场模型中查找（一般是插值出）对应坐标点的风向向量数据，然后将每个随机粒子对应的风向向量同样以纹理形式存储在particlesWind中。风场模型是已知的而且也是必须的，是模拟风场的原型，通常可以从气象部门下载。</p><p><strong>粒子如何表述风场</strong>？</p><p>粒子通过运动来表示：用一串移动的粒子来描述风的轨迹和运动。一串移动的粒子需要不断有新的粒子在头部生成，同时尾部的粒子不断的消亡，也就是说粒子有<strong>生命周期</strong>！前面费劲说的randomizeParticles就是粒子的生成，新生成的粒子颜色鲜艳（当然，具体颜色值和该粒子此时风向向量模长也就是风速有关）！消亡一般靠指定存活时间或者其他特点条件来完成，消亡是必须的一个过程，任何粒子的最终归宿。每一帧中，都对上一帧的粒子颜色进行稀释（比如说乘以0.9这种小于1的数，会导致颜色值越来越小，透明度也越来越小，最终小于某个阈值判定消亡），这样可以达到模拟风效果：风头正劲，风尾消亡。不断有风头涌现，不断有风尾凋零，这样风（看起来）就前进了，而且最终效果和常理吻合。</p><h3 id="五个中间变量"><a href="#五个中间变量" class="headerlink" title="五个中间变量"></a>五个中间变量</h3><p>上面口干舌燥的讲述会用到5个中间变量：</p><p>粒子对应的风向向量：particlesWind纹理，初始值为particlesArray中经纬度坐标对应的风场中风向向量值；</p><p>粒子当前的速度：currentParticlesSpeed纹理，初始值为0，后面会不断的将nextParticlesSpeed变成currentParticlesSpeed，也就是下一步的速度会在下一帧变成当前的速度（故意说的这么绕）；</p><p>粒子当前的位置：currentParticlesPosition纹理，初始值为随机生成的particlesArray，计算时是用粒子上一步的位置加上粒子上一步速度带来的位置增量求得；</p><p>粒子下一步的位置：nextParticlesPosition纹理，初始化为0，可以用粒子当前位置和当前速度来计算得出。可以提前判断是否要消亡，如果要消亡则直接创建新的纹理；</p><p>粒子下一步的速度：nextParticlesSpeed纹理，用粒子下一步的位置去风场中取对应位置的风向向量，然后存在particlesWind纹理中相当于对particlesWind的更新。</p><p>下面详细说一下5个中间变量的操作</p><p><strong>particlesWind纹理</strong>：依次取出currentParticlesPosition纹理中每个像素对应的经纬度坐标，然后去UV纹理中读取风向向量。U、V纹理分别存储了风场中每个数据点的水平、垂直风向向量，这里每个数据点指的是采样经度，比如有的气象网站将全球风场数据存储在360x180的像素中，每个数据点就是每个像素，每个数据点覆盖的采样范围就是1经度x1纬度大小，也就是说1经度x1纬度范围内的风都被平均为了一个风向量。</p><p>所以第一步是将currentParticlesPosition中的像素对应的经纬度坐标规范化为U、V中的采样坐标（或者说像素坐标)，在webGL中变成了归一化的纹理坐标：</p><pre><code class="hljs glsl"><span class="hljs-type">vec2</span> lonLatToUV (<span class="hljs-type">vec2</span> lonLat) &#123;    <span class="hljs-comment">// 过滤到正确的范围，下面的clamp(lonLat.y + 90.0, 0.0, 180.0)也是同样目的</span>    lonLat.x = <span class="hljs-built_in">mod</span>(lonLat.x, <span class="hljs-number">360.0</span>);    <span class="hljs-comment">// 归一化到0.0-1.0得到纹理坐标UV</span>    <span class="hljs-type">vec2</span> UV = <span class="hljs-type">vec2</span>(lonLat.x / <span class="hljs-number">360.0</span>, <span class="hljs-built_in">clamp</span>(lonLat.y + <span class="hljs-number">90.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">180.0</span>) / <span class="hljs-number">180.0</span>);    <span class="hljs-comment">// lonLatToUV每个像素会执行两次，每次取出U或者V，这就是其中的一次，所以只取出了一个值：.r</span>    <span class="hljs-type">float</span> result = <span class="hljs-built_in">texture2D</span>(windTexture, UV).r;&#125;</code></pre><p>直接这样是不够的，因为UV本身的每个值就是很大区域中风场的均值，直接用这些值，相邻风向向量之间方向可能会有突变效果，就是变化不够圆滑（能懂我意思吧？），那咋办？插值！可以用双线性插值或者<strong>三线性插值</strong>！（这里我看的似懂非懂，没有搞的很透）</p><pre><code class="hljs glsl"><span class="hljs-keyword">const</span> <span class="hljs-type">mat4</span> kernelMatrix = <span class="hljs-type">mat4</span>(    <span class="hljs-number">0.0</span>, <span class="hljs-number">-1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">-1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">-5.0</span>, <span class="hljs-number">3.0</span>,  <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">4.0</span>, <span class="hljs-number">-3.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">-1.0</span>, <span class="hljs-number">1.0</span> );<span class="hljs-comment">// 一维插值</span><span class="hljs-type">float</span> oneDimensionInterpolation(<span class="hljs-type">float</span> t, <span class="hljs-type">float</span> p0, <span class="hljs-type">float</span> p1, <span class="hljs-type">float</span> p2, <span class="hljs-type">float</span> p3) &#123;    <span class="hljs-type">vec4</span> tVec4 = <span class="hljs-type">vec4</span>(<span class="hljs-number">1.0</span>, t, t * t, t * t * t);    tVec4 = tVec4 / <span class="hljs-number">2.0</span>;    <span class="hljs-type">vec4</span> pVec4 = <span class="hljs-type">vec4</span>(p0, p1, p2, p3);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dot</span>((tVec4 * kernelMatrix), pVec4);&#125;<span class="hljs-type">float</span> calculateB(<span class="hljs-type">sampler2D</span> windTexture, <span class="hljs-type">float</span> t, <span class="hljs-type">float</span> lon, <span class="hljs-type">float</span> lat) &#123;    <span class="hljs-comment">// interval.x为风场中一个像素对应的经差，这里是取4个经度点</span>    <span class="hljs-type">float</span> lon0 = <span class="hljs-built_in">floor</span>(lon) - <span class="hljs-number">1.0</span>;    <span class="hljs-type">float</span> lon1 = <span class="hljs-built_in">floor</span>(lon);    <span class="hljs-type">float</span> lon2 = <span class="hljs-built_in">floor</span>(lon) + <span class="hljs-number">1.0</span>;    <span class="hljs-type">float</span> lon3 = <span class="hljs-built_in">floor</span>(lon) + <span class="hljs-number">2.0</span>;    <span class="hljs-comment">// 获得了水平方向的四个值</span>    <span class="hljs-type">float</span> p0 = getWindValue(windTexture, <span class="hljs-type">vec2</span>(lon0, lat));    <span class="hljs-type">float</span> p1 = getWindValue(windTexture, <span class="hljs-type">vec2</span>(lon1, lat));    <span class="hljs-type">float</span> p2 = getWindValue(windTexture, <span class="hljs-type">vec2</span>(lon2, lat));    <span class="hljs-type">float</span> p3 = getWindValue(windTexture, <span class="hljs-type">vec2</span>(lon3, lat));    <span class="hljs-keyword">return</span> oneDimensionInterpolation(t, p0, p1, p2, p3);&#125;<span class="hljs-type">float</span> interpolateOneTexture(<span class="hljs-type">sampler2D</span> windTexture, <span class="hljs-type">vec2</span> lonLat) &#123;    <span class="hljs-type">float</span> lon = lonLat.x;    <span class="hljs-type">float</span> lat = lonLat.y;    <span class="hljs-comment">// interval.y为风场中一个像素对应的纬差，这里是取4个纬度点</span>    <span class="hljs-type">float</span> lat0 = <span class="hljs-built_in">floor</span>(lat) - <span class="hljs-number">1.0</span>;    <span class="hljs-type">float</span> lat1 = <span class="hljs-built_in">floor</span>(lat);    <span class="hljs-type">float</span> lat2 = <span class="hljs-built_in">floor</span>(lat) + <span class="hljs-number">1.0</span>;    <span class="hljs-type">float</span> lat3 = <span class="hljs-built_in">floor</span>(lat) + <span class="hljs-number">2.0</span>;    <span class="hljs-type">vec2</span> coef = lonLat.xy - <span class="hljs-built_in">floor</span>(lonLat.xy);    <span class="hljs-comment">// 一种根据临近点线性插值的过程，coef.x、coef.y就是系数并最终求出该值</span>    <span class="hljs-type">float</span> b0 = calculateB(windTexture, coef.x, lon, lat0);    <span class="hljs-type">float</span> b1 = calculateB(windTexture, coef.x, lon, lat1);    <span class="hljs-type">float</span> b2 = calculateB(windTexture, coef.x, lon, lat2);    <span class="hljs-type">float</span> b3 = calculateB(windTexture, coef.x, lon, lat3);    <span class="hljs-keyword">return</span> oneDimensionInterpolation(coef.y, b0, b1, b2, b3);&#125;<span class="hljs-comment">// 双三次内插</span><span class="hljs-type">vec3</span> bicubic(<span class="hljs-type">vec2</span> lonLat) &#123;  <span class="hljs-comment">// 原作者好心保留的维基百科的链接 </span>  <span class="hljs-comment">// https://en.wikipedia.org/wiki/Bicubic_interpolation#Bicubic_convolution_algorithm</span>    <span class="hljs-type">float</span> u = interpolateOneTexture(U, lonLat);    <span class="hljs-type">float</span> v = interpolateOneTexture(V, lonLat);    <span class="hljs-type">float</span> w = <span class="hljs-number">0.0</span>;    <span class="hljs-keyword">return</span> <span class="hljs-type">vec3</span>(u, v, w);&#125;</code></pre><p>最后particlesWind中每个像素就得到了currentParticlesPosition中对应像素代表的经纬度在风场中对应的风向向量，（真的不是故意说的这么绕）并进行了三线性插值，终于可以放心的存入particlesWind中了（泪目）。</p><p><strong>currentParticlesSpeed纹理</strong>（<strong>nextParticlesSpeed</strong>）：</p><p>这好办！直接去上一步辛苦生成的particlesWind中取出对应像素存储的风向向量（存储在像素的R、G分量中的水平、垂直分量），然后对这些向量进行归一化处理</p><pre><code class="hljs glsl"><span class="hljs-type">vec4</span> calcRelativeSpeed(<span class="hljs-type">vec2</span> speed) &#123;  <span class="hljs-type">vec3</span> percent = <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>);  <span class="hljs-comment">// 对风进行归一化,speed.x和speed.y可以是负数</span>  percent.x = (speed.x - uSpeedRange.x) / (uSpeedRange.y - uSpeedRange.x);  percent.y = (speed.y - vSpeedRange.x) / (vSpeedRange.y - vSpeedRange.x);  <span class="hljs-comment">// 风的模</span>  <span class="hljs-type">float</span> normalization = <span class="hljs-built_in">length</span>(percent);<span class="hljs-comment">// 单位是米</span>  <span class="hljs-type">float</span> minRelativeSpeed = -speedFactor * pixelSize;  <span class="hljs-type">float</span> maxRelativeSpeed = speedFactor * pixelSize;  <span class="hljs-type">vec3</span> relativeSpeed = <span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>);  <span class="hljs-comment">// 再转成米</span>  relativeSpeed.x = <span class="hljs-built_in">mix</span>(minRelativeSpeed, maxRelativeSpeed, percent.x);  relativeSpeed.y = <span class="hljs-built_in">mix</span>(minRelativeSpeed, maxRelativeSpeed, percent.y);  <span class="hljs-keyword">return</span> <span class="hljs-type">vec4</span>(relativeSpeed, normalization);&#125;</code></pre><p>上面一大堆看着转来转去，其实就是想归一化，然后对归一化的风乘以方法倍数再乘以像素对应长度最后又变成了米（好吧，有点晕），总之currentParticlesSpeed就是取出风向量，然后进行规范化处理，最后结果也是米。对了这里还有一步，会判断下一步风是否会消亡，如果消亡，则将下一步的风初始为0。这一步最终生成的是<strong>nextParticlesSpeed</strong>！（等等，主角currentParticlesSpeed去哪了？currentParticlesSpeed就是上一帧的nextParticlesSpeed！我只管生成下一步的速度，你问我当前的速度是什么，我不会说无可奉告，我会说：用上一步生成的下一步速度来作为当前速度：<strong><code>that.particlesTextures.currentParticlesSpeed = that.particlesTextures.nextParticlesSpeed</code></strong>;一直会对Speed进行更新，新的变旧然后再产生新的，再变旧。当然，你想追根溯源的话，currentParticlesSpeed和nextParticlesSpeed都被初始化为了0。注意！nextParticlesSpeed每次执行上上面的glsl代码都会被重新<strong>赋值</strong>！！啊？那原来的值丢失了咋办？currentParticlesSpeed早就在它重新赋值前就拷贝了，也就是上面的js代码的执行时机和Cesium中对自定义的primitive有preExecute函数有关（以后有机会详说）。小括号括起来的意思是<strong>nextParticlesSpeed</strong>才是真正的幕后隐藏大佬和受益者）</p><p>that.particlesTextures.currentParticlesSpeed = that.particlesTextures.nextParticlesSpeed;一直会对Speed进行更新，新的变旧然后再产生新的，再变旧。）</p><p>风粒子的生命模拟过程其实已经结束了，下面面临的问题是如何将计算的结果进行展示出来，用到了三个纹理缓冲区（注意上面五个其实是纹理，没有用到深度缓冲区，而这三个都是要进行显示的，所以是三个纹理缓冲区），分别是segments，currentTrails，nextTrails。</p><h3 id="三个帧缓冲区"><a href="#三个帧缓冲区" class="headerlink" title="三个帧缓冲区"></a>三个帧缓冲区</h3><p><strong>segments帧缓冲区</strong></p><p>一旦和直接显示有关了，你就需要考虑最最基础的：视口变换，也就是将三维坐标系下的物体投影到屏幕上，所谓的模型视图投影。segments的顶点着色器做的就是这个：</p><pre><code class="hljs glsl"><span class="hljs-type">vec4</span> calcProjectedCoord(<span class="hljs-type">vec3</span> lonLatLev) &#123;  <span class="hljs-comment">// 将当前粒子经纬度坐标lonLatLev转换为笛卡尔坐标，也就是三维坐标</span>    <span class="hljs-type">vec3</span> particlePosition = convertCoordinate(lonLatLev);  <span class="hljs-comment">// 乘以模型视图投影矩阵，得到规范化空间下的屏幕坐标</span>    <span class="hljs-type">vec4</span> projectedCoord = czm_modelViewProjection * <span class="hljs-type">vec4</span>(particlePosition, <span class="hljs-number">1.0</span>);    <span class="hljs-keyword">return</span> projectedCoord;&#125;</code></pre><p>那么又来了一个问题：如何表示一个粒子呢？如何在屏幕中表示一个粒子呢？算了，更明白的说：如果定义粒子的长和宽？首先，将一个粒子想成一个矩形面片，如何定义这个矩形面片的长和宽呢？宽度好定义，由用户输入粒子宽度，单位为像素，长度就是粒子当前位置和下一步位置之间的距离，方向就是当前粒子位置指向下一步粒子位置（说起来简单做起来难）：</p><pre><code class="hljs glsl"><span class="hljs-comment">// 计算偏移量</span><span class="hljs-type">vec4</span> calcOffset(<span class="hljs-type">vec4</span> currentProjectedCoord, <span class="hljs-type">vec4</span> nextProjectedCoord, <span class="hljs-type">float</span> offsetSign) &#123;  <span class="hljs-comment">// 近裁剪面长宽比</span>    <span class="hljs-type">vec2</span> aspectVec2 = <span class="hljs-type">vec2</span>(aspect, <span class="hljs-number">1.0</span>);    <span class="hljs-comment">// 近裁剪面上的当前位置坐标（没有规范化到0-1范围）</span>    <span class="hljs-type">vec2</span> currentXY = (currentProjectedCoord.xy / currentProjectedCoord.w) * aspectVec2;  <span class="hljs-comment">// 近裁剪面上的下一步位置坐标</span>    <span class="hljs-type">vec2</span> nextXY = (nextProjectedCoord.xy / nextProjectedCoord.w) * aspectVec2;<span class="hljs-comment">// 每一边的偏移长度（所以由用户输入的lineWidth/2）</span>    <span class="hljs-type">float</span> offsetLength = lineWidth / <span class="hljs-number">2.0</span>;  <span class="hljs-comment">// 面片的方向，就是上面说的从当前位置指向下一步位置</span>    <span class="hljs-type">vec2</span> direction = <span class="hljs-built_in">normalize</span>(nextXY - currentXY);    <span class="hljs-comment">// 与运动方向垂直，这才是粒子横向加粗的方向（也就是偏移的方向）</span>    <span class="hljs-type">vec2</span> normalVector = <span class="hljs-type">vec2</span>(-direction.y, direction.x);  <span class="hljs-comment">// 再由近裁剪面坐标转换到规范化空间坐标</span>normalVector.x = normalVector.x / aspect;  <span class="hljs-comment">// 偏移量！</span>    normalVector = offsetLength * normalVector;    <span class="hljs-comment">// 计算偏移量（offsetSign为-+1，就是说是向上偏移还是向下偏移）</span>    <span class="hljs-type">vec4</span> <span class="hljs-keyword">offset</span> = <span class="hljs-type">vec4</span>(offsetSign * normalVector, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">offset</span>;&#125;</code></pre><p>这样，一个粒子就可以生成一个面片了，它的四个坐标都被求出来了，然后就可以根据规范化坐标进行光栅化了，确定四个点之间像素的纹理坐标（其实就是速度speedNormalization，它会根据四个坐标以及坐标对应的值自动插值出像素对应的值，但这里四个点对应speedNormalization相同，最终的结果就是一个面片同色）。那面片的颜色呢？前面说了，是根据速度的大小决定，速度越快越接近红色越不透明，越慢越接近灰色（也可以是其他颜色，自己设置）同时也越透明：</p><pre><code class="hljs glsl">speedNormalization = <span class="hljs-built_in">texture2D</span>(nextParticlesSpeed, particleIndex).a;</code></pre><p>最后的最后，片元着色器就根据speedNormalization颜色值对像素进行上色！这里只上粒子的颜色，所以其他地区该是啥颜色还是啥颜色。</p><p><strong>nextTrails帧缓冲</strong></p><p>在顶点着色器中，传入了规范化空间范围和纹理范围，这样显示空间就是整个屏幕了</p><pre><code class="hljs glsl"><span class="hljs-keyword">attribute</span> <span class="hljs-type">vec3</span> position;<span class="hljs-keyword">attribute</span> <span class="hljs-type">vec2</span> st;<span class="hljs-keyword">varying</span> <span class="hljs-type">vec2</span> textureCoordinate;<span class="hljs-comment">// 插值出每个像素对应的纹理坐标</span><span class="hljs-type">void</span> main() &#123;  textureCoordinate = st;<span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(position, <span class="hljs-number">1.0</span>); <span class="hljs-comment">// 每个像素对应的坐标</span>&#125;</code></pre><p>来到片元着色器，现在分成了片面的颜色和轨迹的颜色，当然，轨迹由面片组成。轨迹是如何生成的呢？也就对于屏幕中某个像素来说，当前帧生成了一个粒子，用红色填充，代表风的头部到达了这里，那么下一帧风的头部去了其他地方，这个像素还要保留上帧生成的红色，这样你才能看到风的身体，而不会永远是头部，但肯定不和上一帧的颜色一样，会变淡，一帧比一帧淡，直到最后风在该像素中消失，如何做到的呢？乘以fadeOpacity就好。它是一个小于1的数，可以认为是退化系数，比如0.9，作用是一个数乘小于1的数，结果会小于这个数的原来值，就是越乘越小，然后设个阈值，小于这个阈值将值变透明。</p><pre><code class="hljs glsl"><span class="hljs-comment">// 每个像素先去segments的纹理中取颜色，如果该像素对应某个粒子面片，那么进一步判断深度</span><span class="hljs-type">vec4</span> pointsColor = <span class="hljs-built_in">texture2D</span>(segmentsColorTexture, textureCoordinate);<span class="hljs-comment">// 是否对应某个粒子的轨迹</span><span class="hljs-type">vec4</span> trailsColor = <span class="hljs-built_in">texture2D</span>(currentTrailsColor, textureCoordinate);<span class="hljs-comment">// 对轨迹的颜色做褪色处理！！这也就是轨迹尾部消失的原因！</span>trailsColor = <span class="hljs-built_in">floor</span>(fadeOpacity * <span class="hljs-number">255.0</span> * trailsColor) / <span class="hljs-number">255.0</span>;<span class="hljs-type">float</span> pointsDepth = <span class="hljs-built_in">texture2D</span>(segmentsDepthTexture, textureCoordinate).r;<span class="hljs-type">float</span> trailsDepth = <span class="hljs-built_in">texture2D</span>(trailsDepthTexture, textureCoordinate).r;<span class="hljs-type">float</span> globeDepth = czm_unpackDepth(<span class="hljs-built_in">texture2D</span>(czm_globeDepthTexture, textureCoordinate));<span class="hljs-built_in">gl_FragColor</span> = <span class="hljs-type">vec4</span>(<span class="hljs-number">0.0</span>);<span class="hljs-comment">// 在这里判断深度。都符合要求后回赋值给gl_FragColor</span><span class="hljs-keyword">if</span> (pointsDepth &lt; globeDepth) &#123;<span class="hljs-built_in">gl_FragColor</span> = <span class="hljs-built_in">gl_FragColor</span> + pointsColor;&#125;<span class="hljs-keyword">if</span> (trailsDepth &lt; globeDepth) &#123;  <span class="hljs-comment">// 至关重要的一步！！但描写都是那么风轻云淡！不加trailsColor看到的永远都是一个点：风的头部在移动</span>  <span class="hljs-comment">// 也正是加了trialsColor，像素才能继承上一帧中该像素的值</span><span class="hljs-built_in">gl_FragColor</span> = <span class="hljs-built_in">gl_FragColor</span> + trailsColor;&#125;gl_FragDepthEXT = <span class="hljs-built_in">min</span>(pointsDepth, trailsDepth);</code></pre><p><strong>最终生成的颜色存储在nextTrails中，currentTrails还是老样子，由上一步的nextTrails赋值得到</strong>！</p><pre><code class="hljs plain">that.framebuffers.currentTrails &#x3D; that.framebuffers.nextTrails;</code></pre><p>状态更新函数永远都是至关重要的！但这里currentTrails和nextTrails区别又不是特别的重要，主要是一个用来更新，一个用来读取，就是nextTrails用来更新，生成的gl_FragColor存到其中，然后下一帧赋值给currentTrails，然后紧接着读取currentTrails。</p><p><strong>screen帧缓冲区</strong></p><p>将nextTrails的值也就是轨迹添加到场景中！！</p><pre><code class="hljs glsl"><span class="hljs-comment">// 屏幕中的某个像素去上一步的nextTrails中look look，看看有没有值。有值则说明有风，没值的话就对应vec3（0.0）</span><span class="hljs-type">vec4</span> trailsColor = <span class="hljs-built_in">texture2D</span>(trailsColorTexture, textureCoordinate);<span class="hljs-comment">// 背面裁剪用的，需要深度</span><span class="hljs-type">float</span> trailsDepth = <span class="hljs-built_in">texture2D</span>(trailsDepthTexture, textureCoordinate).r;<span class="hljs-comment">// 获取球体表面深度。czm开头说明是Cesium封的变量</span><span class="hljs-type">float</span> globeDepth = czm_unpackDepth(<span class="hljs-built_in">texture2D</span>(czm_globeDepthTexture, textureCoordinate));<span class="hljs-keyword">if</span> (trailsDepth &lt; globeDepth) &#123;    <span class="hljs-built_in">gl_FragColor</span> = trailsColor;&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-built_in">gl_FragColor</span> = <span class="hljs-type">vec4</span>(<span class="hljs-number">0.0</span>);&#125;</code></pre><p>OVER了。给我的感觉是screen有些多余。回来再改改。</p><p>粒子模拟可以做很多事情，现在比较忙，以后会好好练习练习，而且这个风场模型还是有一些问题。最后补上一张图：</p><p><img src="https://raw.githubusercontent.com/AOldDriverA/BlogFigurebed/master/img/image-20200709113014248.png" srcset="/img/loading.gif" alt="风场图"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>光线追踪</title>
    <link href="/2020/05/22/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    <url>/2020/05/22/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/</url>
    
    <content type="html"><![CDATA[<p>9月3号终于要开始动笔了，希望能事无巨细的回顾和整理每个细节，秋招也开始了，顺带着理一下之前的图形学，不用专门再复习了。不知道要写多久，慢工出细活吧。</p><p>此篇是对之前闫令琪大神的计算机图形学网课的回顾与总结。</p><p>我并不打算一开始就写光线追踪，回忆有个过程，学习也是，一步一步的来。目前的程序并没有用到可视化引擎。</p><p>先上张图，五月份用cpu跑的，满是噪点，现在计划用webGL重写一下（flag已立）</p><p>9月23号了，秋招大厂基本无缘了，太水了，先夯实基础吧，等我把Cesium，把three、babylon玩的熟一点了再来吧，回归实际和企业所需才是吃饭的正道┭┮﹏┭┮。找到工作后吃饱了再写（flag又又立了）</p><p>11月20日更新：果然鸽了两个月，忙着找工作，写小论文和毕设，后面有时间慢慢补（flag不能乱立，打脸不要太响）</p><p><img src="https://raw.githubusercontent.com/AOldDriverA/BlogFigurebed/master/img/image-20200907161638467.png" srcset="/img/loading.gif" alt="image-20200907161638467"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>光照</title>
    <link href="/2020/05/16/%E5%85%89%E7%85%A7/"/>
    <url>/2020/05/16/%E5%85%89%E7%85%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="计算机图形学中的光照"><a href="#计算机图形学中的光照" class="headerlink" title="计算机图形学中的光照"></a><center>计算机图形学中的光照<center></h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文先大致了解一下光照，然后对最常用的Phone模型结合Cesium可视化引擎进行学习，力求深入和详实。</p><h3 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h3><p>像素是如何表现出颜色的呢？简单的回忆一下，计算机中如何表现出一个物体？首先需要将要表现的物体（无论是虚拟还是实物）抽象成可以用计算机识别的语言：离散的数字，来表现出来，听到这里抽象吧，当然，离散的数字描述一个物体可以有很多种方法，如何又快又准呢？世上安得双全法，性能和效果又得有个被牺牲掉，可成人的世界没有选择题：我想全都要怎么办？只能尽量满足要求：又快又好的代表性方法就是将物体的骨架抽象出来，就像美术画画一样，然后逐渐丰满。骨架是线图，可以离散成顶点然后连线得到，所以这里需要存储顶点信息，此外还需要存储点和点的匹配，就是哪两个点之间连线，带着这些思考开看图形学的渲染流程。第一步是vertexShader，它主要对顶点进行各种位置变换，这些位置变换就是现实中对物体空间位置变换的数学抽象，这里可以用各种表达式，主要是模型、视图、投影三个变换，然后还要变换到规范化立方体内，到这vertexShader算是做完了，折腾完之后还要根据你之前的顶点间的匹配关系：索引来对图形进行转配，并根据屏幕宽度和规范化立方体中物体的对应坐标进行光栅化，光栅化的过程涉及了很多的属性差值（因为顶点自身带有属性，可不只是位置属性），最后就到了fragmentShader中了。之所以进行属性插值是因为骨架肯定不够看，这也就是为什么很多人不喜欢骷髅，需要进行填充，为光栅化后产生的像素找到他们应属的颜色。很幸运，从图形装配到光栅化不需要我们配置，可视化引擎会自动帮我们处理，光栅化后每个像素就具有了顶点属性插值后的结果，也就是说插值后fragmentShader中的像素就具有了颜色和位置（当然，需要vertexShader中有对应的属性和设置），然后将这些颜色输出到颜色缓冲区中就会在屏幕上显示了。你可能会说这里没有光照的事呀？因为这是简化版，光照一般都是在fragmentShader中进行处理，来模拟现实世界。</p><h3 id="着色频率"><a href="#着色频率" class="headerlink" title="着色频率"></a>着色频率</h3><p>Phong模型对每个像素点插值出该点法线然后计算光照（发生在fragmentShader中，因为操作对象是像素）；Gouraud是根据顶点的法向量计算出顶点对应的颜色，然后插值出内部像素的颜色；Flat模型是对每个面进行一次光照计算。</p><h3 id="Blinn-Phong光照模型"><a href="#Blinn-Phong光照模型" class="headerlink" title="Blinn-Phong光照模型"></a>Blinn-Phong光照模型</h3><p>“物体表面反射光的物理机制非常复杂，过去数十年间，固定功能管线均采用经典的Phone反射（光照明）模型的近似方法”—《计算机图形学原理及实践》，非常不错的一本书，适合入门后的进阶，可惜只有基础篇，不过上句话充分说明了Phone模型的应用广泛，在效率和效果之间取得了不错的平衡。</p><p>这里以Blinn-Phong光照模型为例，用到了三种类型：漫反射、镜面反射、环境光反射</p><p>漫反射公式diffuse</p><script type="math/tex; mode=display">L_d=k_d(I/r^2)max(0,n\cdot l)</script><p>$L_d$表示漫反射反射的光能量，$k_d$表示物体吸收能量的比率，$I/r^2$表示物体能接受到的能量与光源散发的总能量的距离平方成反比，$n\cdot l$中表示接收到的光与该接受点的法线和入射光方向向量之间的关系，其中<em>n</em>表示反射点（或面）的法线，<em>l</em>表示光线入射方向（这里是从<strong>反射点</strong>指向<strong>光源</strong>），之所以加个<em>max</em>变成$max(0,n\cdot l)$因为当光线从面的背面射过来时$n\cdot l$为负值，此时无意义（光从背面射过来无意义，这里不考虑折射），所以用max来进行过滤，使其最小值非负。</p><p>公式中没有涉及出射方向，是因为漫反射向各个方向反射的能量相同</p><p>镜面反射specular</p><script type="math/tex; mode=display">L_s=k_s(I/r^2)max(0,n\cdot h)^p</script><p>式中，<strong>h</strong>表示半程向量，即入射方向，$h=\frac{v+l}{||v + l||}$,<strong>v</strong>为入射方向，<strong>l</strong>为观察方向，<strong>n</strong>为法向，计算半程向量比计算反射方向简单却都能表示观察方向与反射方向的夹角大小。p表示幂次方，这样角度偏差一点就不会认定为高光了。</p><p>环境光反射ambient</p><script type="math/tex; mode=display">L_a=k_aI_a</script><p>总体光照模型(Blinn-Phong)：</p><script type="math/tex; mode=display">L=L_a+L_d+L_s=k_aI_a+k_d(I/r^2)max(0,n\cdot l)+k_s(I/r^2)max(0,n\cdot h)^p</script><p>式中的$k_d$常用纹理颜色来代替，以<a href="https://www.bilibili.com/video/BV1X7411F744?p=7" target="_blank" rel="noopener">GAMS101课程</a>中的一段作业代码来表示：</p><pre><code class="hljs glsl">Vector3f result_color = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<span class="hljs-comment">// 对每个光源都要进行一次</span><span class="hljs-keyword">for</span> (auto&amp; light : lights)&#123;  <span class="hljs-comment">// 半程向量</span>  Vector3f half_vector = (light_dir + view_dir).normalized();  <span class="hljs-comment">// 环境光计算，当然ka可以是常数也可以是向量，下式中就是向量，当是向量时可以更精确的描述不同颜色的反射率</span>  <span class="hljs-comment">// 当ka是向量时，由于color也是向量，就需要用到了cwiseProduct，这个公式作用是两个向量对应分量相乘后产生的新向量</span>  <span class="hljs-comment">// amb_light_intensity表示环境光强度</span>  Vector3f ambient_color = ka.cwiseProduct(amb_light_intensity);  <span class="hljs-comment">// 漫反射光计算，这里常用纹理的归一化颜色表示kd</span>  Vector3f diffuse_color = kd.cwiseProduct(light.intensity / light_dis * MAX(<span class="hljs-number">0.0</span>f, normal.normalized().<span class="hljs-built_in">dot</span>(light_dir.normalized())));  <span class="hljs-comment">// 镜面反射光计算</span>  Vector3f specular_color = ks.cwiseProduct(light.intensity / light_dis * <span class="hljs-built_in">pow</span>(MAX(<span class="hljs-number">0.0</span>f, normal.normalized().<span class="hljs-built_in">dot</span>(half_vector.normalized())), p));  <span class="hljs-comment">// 最终反射光计算</span>  result_color += ambient_color + diffuse_color + specular_color;&#125;<span class="hljs-keyword">return</span> result_color * <span class="hljs-number">255.</span>f;</code></pre><p>那么Cesium中又是如何实现的呢？</p><pre><code class="hljs glsl"><span class="hljs-comment">// 先看一下Cesium定义的材质</span>struct czm_material&#123;  <span class="hljs-type">vec3</span> diffuse;  <span class="hljs-type">float</span> specular;  <span class="hljs-type">float</span> shininess;  <span class="hljs-type">vec3</span> normal;  <span class="hljs-type">vec3</span> emission;  <span class="hljs-type">float</span> alpha;&#125;;<span class="hljs-type">vec4</span> czm_phong(<span class="hljs-type">vec3</span> toEye, czm_material material)&#123;  <span class="hljs-comment">/** 漫反射 */</span>  <span class="hljs-type">float</span> czm_private_getLambertDiffuseOfMaterial(<span class="hljs-type">vec3</span> lightDirectionEC, czm_material material) &#123;    <span class="hljs-comment">// 朗伯余弦定律计算反射强度，就是计算lightDirectionEC代表的方向光和material材质法线的夹角</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(lightDirectionEC, material.normal), <span class="hljs-number">0.0</span>);;  &#125;  <span class="hljs-comment">// 这里的diffuse值就是上面公式返回的结果，是一个系数，可以认为是有多少方向光照射到了材质上</span>  <span class="hljs-comment">// 这里方向光直接赋值了，从上往下（模拟太阳在头顶），虽然vec3(0.0, 0.0, 1.0)表示从下到上</span>  <span class="hljs-comment">// 这是因为对方向光的向量取反方向，变成了从照射点指向光源，这样与照射点法向量点乘才为正</span>  <span class="hljs-type">float</span> diffuse = czm_private_getLambertDiffuseOfMaterial(<span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>), material);  <span class="hljs-keyword">if</span> (czm_sceneMode == czm_sceneMode3D) &#123;    <span class="hljs-comment">// 如果是三维模式，水平方向也给一个光照（两个系数简单粗暴的直接相加）</span>    diffuse += czm_private_getLambertDiffuseOfMaterial(<span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>), material);  &#125;  <span class="hljs-comment">/** 镜面反射 */</span>  <span class="hljs-type">float</span> czm_private_getSpecularOfMaterial(<span class="hljs-type">vec3</span> lightDirectionEC, <span class="hljs-type">vec3</span> toEyeEC, czm_material material)  &#123;    <span class="hljs-comment">// reflect为计算反射向量，之所以取负值是因为lightDirection方向为入射点指向光源</span>    <span class="hljs-comment">// 而reflect要输入的是光源指向入射点的正常入射向量，所以lightDirection要取反</span>    <span class="hljs-comment">// 这里可以借鉴GAMS101课程里的半程向量来取reflect计算，效果近似但可以优化效率</span>    <span class="hljs-type">vec3</span> toReflectedLight = <span class="hljs-built_in">reflect</span>(-lightDirectionEC, normalEC);    <span class="hljs-comment">// 计算镜面高光的反射方向与观察方向的夹角</span>    <span class="hljs-type">float</span> specular = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(toReflectedLight, toEyeEC), <span class="hljs-number">0.0</span>);    <span class="hljs-comment">// 这里之所以用pow是为了更形象的描述高光的特性：高光只在接近反射方向明显，稍微偏离反射方向，效果就大大减弱</span>    <span class="hljs-comment">// 这里max(shininess, czm_epsilon2)是为了防止shininess过小，因为任何一个非0数的0次方都为1</span>    <span class="hljs-comment">// shininess过小会导致pow结果接近</span>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">pow</span>(specular, <span class="hljs-built_in">max</span>(shininess, czm_epsilon2));  &#125;  <span class="hljs-comment">// 太阳和月亮带来的高光粗暴的相加</span>  <span class="hljs-type">float</span> specular = czm_private_getSpecularOfMaterial(czm_sunDirectionEC, toEye, material) + czm_private_getSpecularOfMaterial(czm_moonDirectionEC, toEye, material);  <span class="hljs-comment">// 材质本身的漫反射光</span>  <span class="hljs-type">vec3</span> materialDiffuse = material.diffuse * <span class="hljs-number">0.5</span>;  <span class="hljs-comment">// 直接材质漫反射 * 0.5了</span>  <span class="hljs-type">vec3</span> ambient = materialDiffuse;  <span class="hljs-comment">// 看到没，Cesium中定义的环境反射光是由材质本身的漫反射和自发光决定的（相加）</span>  <span class="hljs-comment">// 为什么还要加上自发光emission呢？因为环境光相当于无处不在，会将你全身上下都映上</span>  <span class="hljs-comment">// 而材质的自发光也是浑身上下都发光，所以这两个相加来模拟环境光是相当合理的</span>  <span class="hljs-type">vec3</span> color = ambient + material.emission;  <span class="hljs-comment">// 材质的漫反射颜色 * 漫反射系数</span>  color += materialDiffuse * diffuse;  <span class="hljs-comment">// 材质的镜面反射颜色 * 镜面反射系数</span>  color += material.specular * specular;  <span class="hljs-meta">#ifdef HDR</span>  <span class="hljs-type">float</span> sunDiffuse = czm_private_getLambertDiffuseOfMaterial(czm_sunDirectionEC, material);  color += materialDiffuse * sunDiffuse * czm_sunColor;  <span class="hljs-meta">#endif</span>  <span class="hljs-keyword">return</span> <span class="hljs-type">vec4</span>(color, material.alpha);&#125;</code></pre><p>通过上面可以看到，cesium其实还是做了从简处理，比如没有考虑光的衰减（当然，这里的光源都是太阳和月亮，衰减忽略，局部场景下可以考虑），只考虑的材质本身的颜色，忽略的方向光自身的颜色（当然，这里的光源都是太阳和月亮，发出的光默认都是白光，白光和材质自身的颜色反应后反射出材质自身的颜色，局部场景下可以考虑光源的颜色、环境光的颜色与材质自身颜色作用后的最终反射颜色），对光源类别和数量等的考虑也比较简单。当然，脱离应用场景谈优缺点都是耍流氓，效率和效果之间很难平衡。我的观点也很狭隘，后面还得好好学习。</p><p>未完待续（因为发现光照的内容巨多）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>图形学中的点乘叉乘线性和非线性计算</title>
    <link href="/2020/05/02/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%AD%E7%9A%84%E7%82%B9%E4%B9%98%E5%8F%89%E4%B9%98%E7%BA%BF%E6%80%A7%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%AE%A1%E7%AE%97/"/>
    <url>/2020/05/02/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%AD%E7%9A%84%E7%82%B9%E4%B9%98%E5%8F%89%E4%B9%98%E7%BA%BF%E6%80%A7%E5%92%8C%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%AE%A1%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="图形学中的点乘叉乘线性和非线性计算"><a href="#图形学中的点乘叉乘线性和非线性计算" class="headerlink" title="图形学中的点乘叉乘线性和非线性计算"></a><center>图形学中的点乘叉乘线性和非线性计算<center></h1><h3 id="回忆并整理一下以前关于计算机图形学中基础运算相关的笔记，加深印象"><a href="#回忆并整理一下以前关于计算机图形学中基础运算相关的笔记，加深印象" class="headerlink" title="回忆并整理一下以前关于计算机图形学中基础运算相关的笔记，加深印象"></a>回忆并整理一下以前关于计算机图形学中基础运算相关的笔记，加深印象</h3><h3 id="线性变换："><a href="#线性变换：" class="headerlink" title="线性变换："></a><strong>线性变换</strong>：</h3><p>线性变换是将向量作为输入和输出的一类函数，线性变换就是基向量的变换过程，线性变换矩阵就是变换后基向量的坐标（基向量默认为单位向量）。如果变换矩阵作为行列式其结果表示基向量变换后所构成平行四边形面积或平行六面体体积（如果变换前基向量不为单位向量，则此处为变化率）</p><script type="math/tex; mode=display">\left[\matrix{a&b\\c&d\\}\right]\left[\matrix{x\\y\\}\right]=x\left[\matrix{a\\c\\}\right]+y\left[\matrix{b\\d\\}\right]</script><p>基向量<strong>i</strong>变换后的坐标为（a，c），基向量<strong>j</strong>变换后的坐标为（b，d）</p><p><strong>特点</strong>：保持格网平行且等距的变换，同时保持原点不变。</p><h3 id="Dot（点积或点乘）"><a href="#Dot（点积或点乘）" class="headerlink" title="Dot（点积或点乘）"></a>Dot（点积或点乘）</h3><p><strong>结果</strong>：为一个<strong>值</strong>，表示<strong>b</strong>在<strong>a</strong>上的投影与<strong>a</strong>模的乘积（其实是一个长度，即<strong>b</strong>投影的长度<strong>*a</strong>的长度），当<strong>a</strong>、<strong>b</strong>为单位向量时，值为其夹角的余弦值。</p><p><strong>理解</strong>：点积是一个降维的过程，从上面的结果就可看出，因为投影本身就是降维。 $\vec{a}\cdot\vec{b}$就是将第一个向量<strong>a</strong>转化为（推倒）线性变换矩阵，第二个向量<strong>b</strong>可以看成待变换点。</p><p>计算公式：</p><script type="math/tex; mode=display">\vec{a}\cdot\vec{b} = ||a||*||b||*cos\theta</script><p>点成满足交换律</p><script type="math/tex; mode=display">\vec{a}\cdot\vec{b} = \vec{b}\cdot\vec{a}</script><p>分配律</p><script type="math/tex; mode=display">\vec{a}\cdot(\vec{b} + \vec{c}) = \vec{a}\cdot\vec{b} + \vec{a}\cdot\vec{c}</script><p>结合律</p><script type="math/tex; mode=display">(k*\vec{a})\cdot\vec{b} = \vec{a}\cdot(k*\vec{b}) = k*(\vec{a}\cdot\vec{b})</script><p>二维点积</p><script type="math/tex; mode=display">\vec{a}\cdot\vec{b} = \begin{pmatrix}x_a\\y_b\\\end{pmatrix} * \begin{pmatrix}x_b\\y_a\\\end{pmatrix} = x_ax_b + y_ay_b</script><p>三维点积</p><script type="math/tex; mode=display">\vec{a}\cdot\vec{b} = \begin{pmatrix}x_a\\y_a\\z_a\\\end{pmatrix} * \begin{pmatrix}x_b\\y_b\\z_b\\\end{pmatrix} = x_ax_b + y_ay_b + z_az_b</script><p>点乘作用：</p><ol><li>可以当做<strong>b</strong>在<strong>a</strong>上的投影，根据投影后的结果<strong>b1</strong>对<strong>b</strong>进行分解</li><li>可以判断<strong>a</strong>和<strong>b</strong>的方向</li></ol><h3 id="Cross"><a href="#Cross" class="headerlink" title="Cross"></a>Cross</h3><p><strong>结果</strong>：为一个向量，该向量垂直于<strong>a</strong>、<strong>b</strong>，向量的模（长度大小）为两向量组成平行四边行的面积</p><script type="math/tex; mode=display">||a\times b|| = ||a||*||b||*sin\varphi</script><p>不满足交换律</p><script type="math/tex; mode=display">\vec{a}\times\vec{b} = -\vec{b}\times\vec{a}</script><p>分配律</p><script type="math/tex; mode=display">\vec{a}\times(\vec{b} + \vec{c}) = \vec{a}\times\vec{b} + \vec{a}\times\vec{c}</script><p>结合律</p><script type="math/tex; mode=display">\vec{a}\times(k*\vec{b}) = k*(\vec{a}\times\vec{b})</script><p>三维叉乘</p><script type="math/tex; mode=display">\vec{a}\times\vec{b} = \begin{pmatrix}y_az_b - y_bz_a\\z_ax_b - z_bx_a\\x_ay_b - x_by_a\\\end{pmatrix}</script><p>简化算法</p><script type="math/tex; mode=display">\vec{a}\times\vec{b} = A*\vec{b} = \begin{pmatrix}0 & -z_a & y_a\\z_a & 0 & -x_a\\-y_b & x_a & 0\\\end{pmatrix} * \begin{pmatrix}x_b\\y_b\\z_b\\\end{pmatrix}</script><p>叉乘作用：</p><ol><li>判断左和右，<strong>a</strong> x <strong>b</strong> &gt; 0， 则<strong>b</strong>在<strong>a</strong>的左侧，同理可判断内和外，比如三角形A、B、C三点和待判断点P，若AB x AP与BC x BP和CA x CP结果同正或同负，则点在三角形内</li></ol><p>矩阵：</p><p>满足分配律和结合律</p><script type="math/tex; mode=display">(AB)^T=B^TA^T</script><script type="math/tex; mode=display">AA^{-1}=A^{-1}A=I</script><script type="math/tex; mode=display">(AB)^{-1}=B^{-1}A^{-1}</script><h3 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h3><p>首先是线性变换，以三维为例：（等等！听这口气还有非线性的？）</p><p>缩放（x轴缩放a倍，y轴缩放b倍，z轴缩放c倍）：</p><script type="math/tex; mode=display">\left[\matrix{x^,\\y^,\\z^,\\}\right] = \left[\matrix{ax\\by\\cz\\}\right]=\left[\matrix{a&0&0\\0&b&0\\0&0&c\\}\right]\left[\matrix{x\\y\\z\\}\right]</script><p>对称（关于x轴对称，则x坐标不变，y、z坐标取反）</p><script type="math/tex; mode=display">\left[\matrix{x^,\\y^,\\z^,\\}\right]=\left[\matrix{1&0&0\\0&-1&0\\0&0&-1\\}\right]\left[\matrix{x\\y\\z\\}\right]</script><p>错切(以x轴为错切方向)</p><script type="math/tex; mode=display">\left[\matrix{x^,\\y^,\\z^,\\}\right]=\left[\matrix{1&a&0\\0&1&0\\0&0&1\\}\right]\left[\matrix{x\\y\\z\\}\right]</script><p>旋转</p><p>绕x轴的旋转矩阵：$\left[\matrix{<br>1&amp;0&amp;0\<br>0&amp;cos\alpha&amp;-sin\alpha\<br>0&amp;sin\alpha&amp;cos\alpha\<br>}\right]$，</p><p>绕y轴的旋转矩阵：$\left[\matrix{<br>cos\alpha&amp;0&amp;sin\alpha\<br>0&amp;1&amp;0\<br>-sin\alpha&amp;0&amp;cos\alpha\<br>}\right]$，                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         </p><p>绕z轴的旋转矩阵：$\left[\matrix{<br>cos\alpha&amp;-sin\alpha&amp;0\<br>sin\alpha&amp;cos\alpha&amp;0\<br>0&amp;0&amp;1\<br>}\right]$<br>旋转矩阵的逆变换就是转置矩阵$R^{-1}=R^T$。</p><h3 id="非线性变换："><a href="#非线性变换：" class="headerlink" title="非线性变换："></a>非线性变换：</h3><p>平移</p><script type="math/tex; mode=display">\left[\matrix{x^,\\y^,\\z^,\\1\\}\right]=\left[\matrix{x+a\\y+b\\z+c\\1\\}\right]=\left[\matrix{1&0&0&a\\0&1&0&b\\0&0&1&c\\0&0&0&1\\}\right]\left[\matrix{x\\y\\z\\1\\}\right]</script><p>平移不属于线性变换，因为它不满足线性变换中“变换前后原点不变”这一性质，无法用x、y、z变量来表达平移的距离常数。但平移操作和旋转缩放这些往往一起发生相互依赖，所以必须想个办法把它俩“中和”起来，上式就是“中和”的结果，变成了齐次变换矩阵，属于仿射变换。线性变换到齐次变换增加了一个维度来容纳非线性变换的平移，这样就可以用一个矩阵来同时容纳线性和平移（小孩才做选择题，大人是全都要）。即使都在一个矩阵里，也是先进行线性变换然后再进行平移变换。</p><p>这里变换前点的坐标由(x, y, z)变成了(x, y, z, 1)，对应变换后的向量变成了(1, 0, 0, 0)、(0, 1, 0, 0)、(0, 0, 1, 0)，为啥点的后面拓展的维度值为1而向量拓展的值为0呢？其实是为了保持“中和”后线性变换和平移变换各自属性的不变性，也只有属性不变“中和”才是有意义的，才能得出正确的结果：</p><ol><li>3D $point = (x,y,z,1)^T$</li><li>3D $point = (x,y,z,0)^T$</li><li>$vector + vector = vector$</li><li>$point - point = vector$</li><li>$point + vector = point$</li><li>$point + point = centerPoint(两个点的中点)$</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Cesium中的Clock</title>
    <link href="/2020/05/01/Cesium%E4%B8%AD%E7%9A%84Clock/"/>
    <url>/2020/05/01/Cesium%E4%B8%AD%E7%9A%84Clock/</url>
    
    <content type="html"><![CDATA[<h1 id="Cesium中的Clock类"><a href="#Cesium中的Clock类" class="headerlink" title="Cesium中的Clock类"></a><center>Cesium中的Clock类<center></h1><p>Cesium中的clock主要是为了追踪动画，接收如下参数：</p><pre><code class="hljs javascript">@param &#123;JulianDate&#125; [options.startTime] （动画）开始时间@param &#123;JulianDate&#125; [options.stopTime] 结束时间@param &#123;JulianDate&#125; [options.currentTime] 当前时间 @param &#123;<span class="hljs-built_in">Number</span>&#125; [options.multiplier=<span class="hljs-number">1.0</span>] 快进倍数@param &#123;ClockStep&#125; [options.clockStep=ClockStep.SYSTEM_CLOCK_MULTIPLIER] 决定clock的调用是依赖帧还是系统时钟@param &#123;ClockRange&#125; [options.clockRange=ClockRange.UNBOUNDED] 当到达开始时间或结束时间时应该如何工作（比如LOOP_STOP,循环播放）@param &#123;<span class="hljs-built_in">Boolean</span>&#125; [options.canAnimate=<span class="hljs-literal">true</span>] 是否有动画@param &#123;<span class="hljs-built_in">Boolean</span>&#125; [options.shouldAnimate=<span class="hljs-literal">false</span>] 是否可以开始动画canAnimate和ShouldAnimate同时成立才能有动画</code></pre><p>如果没定义当前时间：如果startTime存在则与其相同，如果stopTime存在则为其前一天，如果两者也都不存在，则以该函数运行时的系统时间作为当前时间：</p><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (!defined(currentTime)) &#123;<span class="hljs-comment">// if not specified, current time is the start time,</span><span class="hljs-comment">// or if that is not specified, 1 day before the stop time,</span><span class="hljs-comment">// or if that is not specified, then now.</span><span class="hljs-keyword">if</span> (defined(startTime)) &#123;currentTime = JulianDate.clone(startTime);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (defined(stopTime)) &#123;currentTime = JulianDate.addDays(stopTime, <span class="hljs-number">-1.0</span>, <span class="hljs-keyword">new</span> JulianDate());&#125; <span class="hljs-keyword">else</span> &#123;currentTime = JulianDate.now();&#125;&#125; <span class="hljs-keyword">else</span> &#123;currentTime = JulianDate.clone(currentTime);&#125;</code></pre><p>JulianDate为儒略日，Cesium提供了JulianDate与UTC（协调世界时）的转换。JulianDate的创建用到了julianDayNumber（儒略日总天数），secondsOfDay（该天中的总秒数），timeStandard（时间标准，默认为UTC）</p><p>如果没有定义startTime，则以currentTime作为其值。如果没有定义stopTime，则以startTime+1天作为stopTime。</p><p>说一下它的几个参数</p><pre><code class="hljs javascript"><span class="hljs-comment">// 时间按照指定间隔跳跃 间隔为multiplier</span>ClockStep.TICK_DEPENDENT: <span class="hljs-number">0</span>,<span class="hljs-comment">// 上次调用至今的系统时间间隔 * multiplier</span><span class="hljs-comment">// 通俗的说就是此次间隔时间按照上一次调用时的间隔时间</span><span class="hljs-comment">// 可以理解为根据帧，但不死板，会根据机器刷新率以及场景</span><span class="hljs-comment">// 动态决定每秒帧数</span>ClockStep.SYSTEM_CLOCK_MULTIPLIER: <span class="hljs-number">1</span>, <span class="hljs-comment">// 将时钟设置为当前系统时间，忽略所有其他设置。</span>ClockStep.SYSTEM_CLOCK : <span class="hljs-number">2</span></code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 无穷执行，会朝着这个方向一直运行下去，直到海枯石烂</span>ClockRange.UNBOUNDED: <span class="hljs-number">0</span>,<span class="hljs-comment">// 正常执行，会始于startTime止于stopTime（该开始开始，该结束结束）</span>ClockRange.CLAMPED: <span class="hljs-number">1</span>,<span class="hljs-comment">// 循环执行，到结尾了会跳转到开头重新执行</span>ClockRange.LOOP_STOP: <span class="hljs-number">2</span>,</code></pre><p>clock中最为重要的一个函数就是tick了：</p><pre><code class="hljs javascript">Clock.prototype.tick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-comment">// 获取当前时间戳 （getTimestamp有点意思，它返回毫秒，如果你指定了某种时间系统</span>  <span class="hljs-comment">//（performance），它会调用该系统来获取时间，当然你需要去修改该函数的源码。默认</span>  <span class="hljs-comment">// 情况下时间系统未定义，获取的时Date.now()；</span><span class="hljs-keyword">var</span> currentSystemTime = getTimestamp();  <span class="hljs-comment">// 获取"当前"时间（注意，此处this._currentTime表示上一次Clock.tick运行时的值，</span>  <span class="hljs-comment">// 所以准确的说应该叫passTime）</span>  <span class="hljs-keyword">var</span> currentTime = JulianDate.clone(<span class="hljs-keyword">this</span>._currentTime);  <span class="hljs-comment">// 如果动画存在并且应该被播放（也就是说动画被触发了）</span>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.canAnimate &amp;&amp; <span class="hljs-keyword">this</span>._shouldAnimate) &#123;    <span class="hljs-keyword">var</span> clockStep = <span class="hljs-keyword">this</span>._clockStep;    <span class="hljs-comment">// 如果依照当前系统时间</span>    <span class="hljs-keyword">if</span> (clockStep === ClockStep.SYSTEM_CLOCK) &#123;      <span class="hljs-comment">// 获取当前系统时间（JulianDate.now返回的是Date）</span>      currentTime = JulianDate.now(currentTime);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// 否则就先设置乘数</span>    <span class="hljs-keyword">var</span> multiplier = <span class="hljs-keyword">this</span>._multiplier;<span class="hljs-comment">// 以multiplier为间隔</span>    <span class="hljs-keyword">if</span> (clockStep === ClockStep.TICK_DEPENDENT) &#123;        <span class="hljs-comment">// 将currentTime加上multiplier并返回结果</span>      currentTime = JulianDate.addSeconds(currentTime, multiplier, currentTime);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 根据当前帧的系统时间-上一帧的系统时间得出两帧时间差（毫秒）</span>      <span class="hljs-keyword">var</span> milliseconds = currentSystemTime - <span class="hljs-keyword">this</span>._lastSystemTime;        <span class="hljs-comment">// 当前的时间就是currentTime + 上一步求出的时间差，因为时毫秒所以/1000.0</span>    currentTime = JulianDate.addSeconds(currentTime, multiplier * (milliseconds / <span class="hljs-number">1000.0</span>), currentTime);    &#125;    <span class="hljs-keyword">var</span> clockRange = <span class="hljs-keyword">this</span>.clockRange;    <span class="hljs-keyword">var</span> startTime = <span class="hljs-keyword">this</span>.startTime;    <span class="hljs-keyword">var</span> stopTime = <span class="hljs-keyword">this</span>.stopTime;      <span class="hljs-comment">// 如果时一直正常执行模式</span>    <span class="hljs-keyword">if</span> (clockRange === ClockRange.CLAMPED) &#123;        <span class="hljs-comment">// 当前时间小于开始时间</span>    <span class="hljs-keyword">if</span> (JulianDate.lessThan(currentTime, startTime)) &#123;          <span class="hljs-comment">// 将开始时间赋值给当前时间（然后搓搓手耐心的等待开始吧）</span>      currentTime = JulianDate.clone(startTime, currentTime);        <span class="hljs-comment">// 当前时间大于结束时间</span>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (JulianDate.greaterThan(currentTime, stopTime)) &#123;          <span class="hljs-comment">// 不行了，超时了，得抓紧结束，先把结束时间赋值给当前时间</span>      currentTime = JulianDate.clone(stopTime, currentTime);          <span class="hljs-comment">// 提交结束事件</span>    <span class="hljs-keyword">this</span>.onStop.raiseEvent(<span class="hljs-keyword">this</span>);    &#125;      <span class="hljs-comment">// 如果是循环模式  </span>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clockRange === ClockRange.LOOP_STOP) &#123;        <span class="hljs-comment">// 当前时间小于开始时间，则和上一步一样，将当前时间更新为开始时间</span>      <span class="hljs-keyword">if</span> (JulianDate.lessThan(currentTime, startTime)) &#123;    currentTime = JulianDate.clone(startTime, currentTime);      &#125;        <span class="hljs-comment">// 当前时间大于结束时间</span>    <span class="hljs-keyword">while</span> (JulianDate.greaterThan(currentTime, stopTime)) &#123;        <span class="hljs-comment">// 将大于的部分加上startTime返回给当前时间（嗯，一想确实比较合理）  </span>      currentTime = JulianDate.addSeconds(startTime, JulianDate.secondsDifference(currentTime, stopTime), currentTime);        <span class="hljs-comment">// 提交结束时间</span>      <span class="hljs-keyword">this</span>.onStop.raiseEvent(<span class="hljs-keyword">this</span>);    &#125; &#125;&#125;&#125;  <span class="hljs-comment">// 更新当前时间 </span>  <span class="hljs-keyword">this</span>._currentTime = currentTime;  <span class="hljs-comment">// 更新当前时间（这一帧对应的系统时间）</span>  <span class="hljs-keyword">this</span>._lastSystemTime = currentSystemTime;  <span class="hljs-comment">// 触发回调函数</span>  <span class="hljs-keyword">this</span>.onTick.raiseEvent(<span class="hljs-keyword">this</span>);  <span class="hljs-keyword">return</span> currentTime;&#125;;</code></pre><p>总结来说，其实就是更新currentTime。如果你按照系统时间来更新，那好办，我直接获取系统的<strong>当前时间</strong>，然后return，就省略了80%的代码。如果我按照某个固定时间或者依据帧数时间，就得考虑很多情况，如果当前时间在合理时间区间内，则依据multiplier和对应的计算规则得到当前时间，如果时间超限（小于起始时间或大于终止时间）那么又会根据你动画展示模式分为正常执行和循环执行两种不同处理方式，最终计算得到合理的<strong>当前时间</strong>。</p><p>这里扯一下固定时间和帧数时间，其实就是固定增量时间fixedUpdate和可变增量时间update，固定增量时间就是每两帧运行的时间间隔固定，优点是不用动脑子而且可以当做一个已知量来和物理逻辑或计算进行绑定，缺点是固定就会不灵活。比如给一个动画设置60帧每秒，也就是一帧16.7豪秒左右，也就是说每隔16.7毫秒就会进行一次帧操作，当动画简单时问题不大（当然，本来GPU能进行每秒144帧丝滑刷新的，结果仍然60帧，虽然很不爽但能接受），但复杂时，每帧的执行时间很可能超过16.7毫秒，上一帧还没得出结果还没来得及进行展示，下一帧就不期而遇，慌慌张张的挤了过来，中间可能丢了一些帧，会造成抖动效果（不知道我的理解对不对，欢迎讨论）。</p><p>帧数和刷新率的关系也能扯一些，这里的帧数是指每秒渲染好的画面次数，刷新率是指屏幕显示的刷新率，屏幕每次刷新都要去颜色缓冲区中将渲染好的画面取出来，如果你GPU很强，每秒渲染120帧，可我显示器每秒只能显示60帧，那很抱歉，你每两次中有一次是浪费的，而且帧数太多也不好，我从缓冲区中取画面，取到一半你就又画好了一张，然后我熟若无睹的接着取，这样会造成上半部分是旧帧下半部分是新帧，上下部分内容很可能不匹配（如果某大佬的180°回身甩狙），造成了画面的撕裂。这样催生出了一个产业：显示器将自动和帧率匹配，如英伟达的Gsync技术（是的，按摩店也有freesync，但总是日常180°翻身，但我还是要歇斯底里的吼一句：AMD YES！！）。鄙人前年买笔记本的时候这还是个卖点（1070推144刷新率，也就csgo能达到，守望勉强，最爱玩的战地1、5顶配下也分别只有100-70帧，不过寒霜航空引擎真的牛皮）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS中new的实现</title>
    <link href="/2020/04/27/JS%E4%B8%ADnew%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/04/27/JS%E4%B8%ADnew%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="JS中new的实现以及它背后的故事"><a href="#JS中new的实现以及它背后的故事" class="headerlink" title="JS中new的实现以及它背后的故事"></a><center>JS中new的实现以及它背后的故事<center></h1><h3 id="new的作用"><a href="#new的作用" class="headerlink" title="new的作用"></a>new的作用</h3><p>规范的说：new关键字可以用来创建具有构造函数的<strong>系统内置对象</strong>的实例和<strong>用户自定义类型</strong>对象的实例，通俗的说就是可以通过函数来创建一个实例对象。</p><p>new操作符包含了四个操作（MDN的原文解释）：</p><ol><li>创建一个空的简单JavaScript对象（即{}）；</li><li>链接该对象（即设置该对象的构造函数）到另一个对象；</li><li>将步骤1新创建的对象作为this的上下文；</li><li>如果该函数没有返回对象，则返回this。</li></ol><p>下面结合例子说一下</p><pre><code class="hljs javascript"><span class="hljs-comment">// 构造函数部分</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age</span>) </span>&#123;    <span class="hljs-keyword">this</span>.name = name;    <span class="hljs-keyword">this</span>.age = age;&#125;<span class="hljs-comment">// 原型函数：自我介绍功能</span>Person.prototype.introduce = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello everyone, My name is "</span>  + <span class="hljs-keyword">this</span>.name + <span class="hljs-string">" and I am "</span> + <span class="hljs-keyword">this</span>.age + <span class="hljs-string">" years old"</span>;&#125;<span class="hljs-comment">// 实例对象</span><span class="hljs-keyword">let</span> me = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"yaoyuan"</span>, <span class="hljs-string">"25"</span>) <span class="hljs-comment">// 不错，我已不再年轻</span><span class="hljs-built_in">console</span>.log(me.introduce）</code></pre><p>用代码来解释之前的话就是：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个空对象</span><span class="hljs-keyword">let</span> obj = &#123;&#125;;<span class="hljs-comment">// 将构造函数的原型添加到这个空对象的原型链上</span>obj.__proto__ = Person.prototype;<span class="hljs-comment">// 借用构造函数并传入参数，就是用obj给this赋值</span><span class="hljs-keyword">let</span> result = Person.call(obj, <span class="hljs-built_in">arguments</span>);<span class="hljs-comment">// 如果之前借用构造函数来初始化的result</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">"obj"</span> ? result : obj;</code></pre><p><code>obj.__proto__ = Person.prototype</code> 是为了继承Person中原型链上的属性，<code>Person.call(obj, arguments)</code> 借用构造函数，这两个组合拳使得new关键字的作用和组合继承很想，更准确地说是<strong>寄生组合式</strong>模式。忍不住回顾一下继承的特点（ES5）：</p><p><strong>原型链继承</strong>：</p><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<span class="hljs-comment">// 1行 这里创建了子元素构造函数</span>SubType.prototype = <span class="hljs-keyword">new</span> SuperType(); <span class="hljs-comment">// 2行 这里发生了原型链继承</span><span class="hljs-keyword">let</span> instance = <span class="hljs-keyword">new</span> SubType();<span class="hljs-comment">// 3行 这里实例化的子元素</span></code></pre><p>特点：所有实例共享父元素的所有属性和方法</p><p>缺点：</p><ol><li>不可修改父元素的属性和方法（一但修改所有子实例的对应属性也跟着变）；</li><li><strong>不能给父元素传参数</strong>（借用高程的一句话：”应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数“,又跑到缺点2上面，被所有子元素共享丧失独立性。同时在创建子元素时传的参数进入到了子元素的构造函数内部，父元素实例化时不在子元素的构造函数内部，无法直接很丝滑自然的享受到参数，当然真想赋值也不是没办法就回到了开头高程那句话，禁止套娃）；</li></ol><p><strong>借用构造函数</strong>：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">// 1行 这里创建了子元素构造函数</span>SuperType.call(<span class="hljs-keyword">this</span>);<span class="hljs-comment">// 2行 这里发生了借用构造函数继承</span>&#125;  <span class="hljs-comment">// 3行 这里啥也没干，不写空得慌</span></code></pre><p>特点：所有子元素具有父元素的所有属性和方法，且各自独立互不影响同时还可以传递参数</p><p>缺点：</p><ol><li>每创建一个子元素都会调用一次父元素的构造函数（每个方法都会在每个实例上重新创建一次），没有起到很好的重用效果；</li><li>父元素原型中保留的方法被毫无保留的丢弃了；</li></ol><p><strong>组合继承</strong>：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">// 1行 这里创建了子元素构造函数</span>SuperType.call(<span class="hljs-keyword">this</span>);<span class="hljs-comment">// 2行 这里发生了借用构造函数继承</span>&#125;<span class="hljs-comment">// 3行 这里啥也没干，不写空得慌</span>SubType.prototype = <span class="hljs-keyword">new</span> SuperType();<span class="hljs-comment">// 2行 这里发生了原型链继承</span><span class="hljs-keyword">let</span> instance = <span class="hljs-keyword">new</span> SubType();<span class="hljs-comment">// 3行 这里实例化的子元素</span></code></pre><p>没错，像上面无脑拼接后就是组合继承，赶赶单单，特点：去两个极端之长补两个极端之短</p><p>缺点：无论在什么情况下，都会调用两次超类型的构造函数，一次是在创建子类型的原型时（第2个第2行），另一次是在子类型构造函数内部（第1个第2行。你看，无脑拼接总是会有点瑕疵）</p><p><strong>寄生组合式继承</strong>：</p><p>寄生组合式继承又得扯一堆，长话短说“不必为了指定子类型的原型而调用超类型的构造函数”：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params">name</span>) </span>&#123;<span class="hljs-comment">// 为了体现能传参,象征性的加了一个name</span>SuperType.call(<span class="hljs-keyword">this</span>, name);&#125;<span class="hljs-keyword">let</span> prototype = object(superType.prototype);<span class="hljs-comment">// 对父元素的原型链进行了一次浅复制</span>prototype.constructor = subType;<span class="hljs-comment">// 弥补重写原型而失去的默认constructor属性</span>subType.prototype = prototype;<span class="hljs-comment">// 指定对象</span></code></pre><p>特点：它（指组合继承）的优点就是我的优点，它的缺点还是我的优点</p><p>回到new上来，<code>return typeof result === &quot;obj&quot; ? result : obj;</code>是为了判断上一步（迈在继承畅想之前的那一步） <code>let result = Person.call(obj, arguments)</code>中有没有返回值（即result是否为空），不论如何都会返回这个崭新出厂的obj对象(感觉可以省略掉result的创建，直接返回obj，不太明白为什么不这么做，优雅？“<strong>不太明白</strong>”的地方就是我和大佬毫厘之间千里之外的差距）。</p><h3 id="new的模拟实现"><a href="#new的模拟实现" class="headerlink" title="new的模拟实现"></a>new的模拟实现</h3><p>墙裂推荐<a href="https://github.com/mqyqingfeng" target="_blank" rel="noopener">冴羽</a>的JavaScript深入专栏中的<a href="https://github.com/mqyqingfeng/Blog/issues/13" target="_blank" rel="noopener">new模式实现</a>；</p><p>没事走两步：</p><p>第一步，抓取构造函数指向的原型函数</p><p>第二步，抓取构造函数</p><p>其实new的实现和空对象的寄生组合式继承在思想上非常像</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">NewObject</span>(<span class="hljs-params">...args</span>) </span>&#123;<span class="hljs-comment">// ES6中的三点运算符，对参数位置的情况很适用</span><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();    <span class="hljs-keyword">let</span> Constructor = <span class="hljs-built_in">Array</span>.prototype.shift.call(args);<span class="hljs-comment">// 首先，参数数组args是伪数组，不具备数组的很多方法，因此使用Array.prototype.shift.call()方法来借用，同时shift会修改原数组，移除第一个</span>    <span class="hljs-comment">// 第一步</span>    obj.__proto__ = Constructor.prototype;<span class="hljs-comment">// 实例的原型指向构造函数原型，这样才能实现构造函数中原型函数的继承，直接浅复制拷贝副本，类似寄生组合中对父元素原型链的拷贝</span>    <span class="hljs-comment">// 第二步</span>    Constructor.apply(obj, args);<span class="hljs-comment">// 借用构造函数</span>    <span class="hljs-keyword">return</span> obj;<span class="hljs-comment">// 返回该对象</span>&#125;</code></pre><p>写完了你可能会有疑问：</p><p><img src="data:image/jpeg;base64,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" srcset="/img/loading.gif" alt=""></p><p>（抱歉我的水平就这）</p><p>还记得我之前的“<strong>不太明白</strong>”么？（如果记忆能停留几个7秒的话应该还记得，就在“new的模拟实现”上面第二行），为什么要多此一举的来个result并判断返回值类型呢？</p><p>我和大佬们的差距出来了：构造函数如果有返回值，返回值的类型会对构造的结果产生影响！</p><p>第一种情况：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 之前的例子，函数没有返回值</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age</span>) </span>&#123;    <span class="hljs-keyword">this</span>.name = name;    <span class="hljs-keyword">this</span>.age = age;&#125;<span class="hljs-keyword">let</span> me = <span class="hljs-keyword">new</span> Person (<span class="hljs-string">"耀元"</span>, <span class="hljs-string">"25"</span>);<span class="hljs-built_in">console</span>.log(me.name);<span class="hljs-comment">// “英俊的”（电脑基于客观事实自动补齐）耀元</span><span class="hljs-built_in">console</span>.log(me.age);<span class="hljs-comment">// 25</span></code></pre><p>构造函数没有返回值的时候，构造完毕返回给me元素的是this的值，this的值就是构造函数中一通操作的对象的地址。</p><p>第二种情况：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age</span>) </span>&#123;    <span class="hljs-keyword">this</span>.name = name;    <span class="hljs-keyword">this</span>.age = age;    <span class="hljs-keyword">return</span> &#123;        age: age,        height: <span class="hljs-number">180.0</span>,    &#125;&#125;<span class="hljs-keyword">let</span> me = <span class="hljs-keyword">new</span> Person (<span class="hljs-string">"耀元"</span>, <span class="hljs-string">"25"</span>);<span class="hljs-built_in">console</span>.log(me.name);<span class="hljs-comment">// undefinde (我张某人不配拥有姓名)</span><span class="hljs-built_in">console</span>.log(me.age);<span class="hljs-comment">// 25</span><span class="hljs-built_in">console</span>.log(me.height); <span class="hljs-comment">// 180</span></code></pre><p>上段代码很明显，构造函数里就算构造了一个宇宙没啥作用，因为你传不出来，最终的结果就是你构造函数中最后return的对象。</p><p>第三种情况：</p><p>构造函数返回的是基本类型值</p><p><img src="https://raw.githubusercontent.com/AOldDriverA/BlogFigurebed/master/img/20200427131649.jpg" srcset="/img/loading.gif" alt=""></p><p>大家不要被“英俊的耀元”迷惑了双眼，重点应该放在那段我看不懂的英文上：</p><blockquote><p>Primitive value returned from constructor will be lost when called with ‘new’</p></blockquote><p>用有道的话来说就是：当使用“new”调用构造函数时，基本类型值(string number boolean undefined null 我都试了)会在返回途中丢失（就是return没用，可以忽略这个单词），你收到的就是那个独一无二的构造函数中的对象。</p><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age</span>) </span>&#123;    <span class="hljs-keyword">this</span>.name = name;    <span class="hljs-keyword">this</span>.age = age;    <span class="hljs-keyword">return</span> <span class="hljs-string">"180,180,180"</span><span class="hljs-comment">// 就算是男人们梦寐以求的三个180，它也会当做没看无情抛掉</span>&#125;<span class="hljs-keyword">let</span> me = <span class="hljs-keyword">new</span> Person (<span class="hljs-string">"耀元"</span>, <span class="hljs-string">"25"</span>);<span class="hljs-built_in">console</span>.log(me.name);<span class="hljs-comment">// "耀元"</span><span class="hljs-built_in">console</span>.log(me.age);<span class="hljs-comment">// 25</span></code></pre><p>所以，构造函数返回值的有无和返回类型会影响构造函数的调用结果</p><p>所以，最终版<strong>new</strong>的模拟实现如下：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">NewObject</span> (<span class="hljs-params">...args</span>) </span>&#123;    <span class="hljs-comment">// 新建一个欠返回的对象</span>    <span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();    <span class="hljs-comment">// 获取传入的第一个参数，同时将其从args中删除（shift为删除数组首元素，会改变原数组）</span>    <span class="hljs-comment">// 这里第一个参数为输入的构造函数，其余参数为该构造函数的参数</span>    <span class="hljs-keyword">let</span> Constructor = <span class="hljs-built_in">Array</span>.prototype.shift.call(args);    <span class="hljs-comment">// 将构造函数的原型稳稳的交付给obj,并希望它以后也能用上</span>    obj.__proto__ = Constructor.prototype;    <span class="hljs-comment">// 领着obj走一遍构造流程，把收货再交给result</span>    <span class="hljs-keyword">let</span> result = Constructor.call(obj, args);    <span class="hljs-comment">// 根据result的有无和类型来绝对最终的返回结果。小心点总是好的</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">"object"</span> ? result : obj;&#125;</code></pre><p><strong>OVER</strong>！（看到没，我和大佬的差距看起来只是个result，其实是洋洋洒洒的三分之一篇幅 ( Ĭ ^ Ĭ ) ）</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>深深地被“<strong>最终版new的模拟实现</strong>”中<code>Constructor.call(obj, args)</code>的作风给感动了，构造的过程相当于盖房，收到新雇主obj的买房指令，然后（去堆内存中）找空地根据图纸流程（早已确定的构造函数）进行建造，最后把钥匙（this）交给obj，Constructor则事了拂衣去，深藏功与名，又和人生一样，给新baby（obj）打拼一切，已经有的财产（原型中的方法），可以直接给他，没有的但需要的（构造函数中的属性），从头开始干，最后毫无保留的奉献。你眼中的一个new只是JS开始的第一步，只是一个赶赶单单的返回结果，但其实就是人生的一个缩影，很多时候父母的付出你是看不到的，你看到的只是一个结果。想要一个结果，如果父母有钱可以直接new一个，没钱就得老老实实一步一步来短点三五月长点就是一辈子，虽然最终都是同一个。</p><p><img src="data:image/jpeg;base64,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" srcset="/img/loading.gif" alt=""></p><p>（怎么写成了略微催泪向）</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
