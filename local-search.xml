<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>线性变换点乘叉乘计算公式</title>
    <link href="/2020/05/02/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E7%82%B9%E4%B9%98%E5%8F%89%E4%B9%98%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F/"/>
    <url>/2020/05/02/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E7%82%B9%E4%B9%98%E5%8F%89%E4%B9%98%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="图形学中的线性变换点乘叉乘计算"><a href="#图形学中的线性变换点乘叉乘计算" class="headerlink" title="图形学中的线性变换点乘叉乘计算"></a><center>图形学中的线性变换点乘叉乘计算<center></h1><h3 id="回忆并整理一下以前关于计算机图形学中基础运算相关的笔记，加深印象"><a href="#回忆并整理一下以前关于计算机图形学中基础运算相关的笔记，加深印象" class="headerlink" title="回忆并整理一下以前关于计算机图形学中基础运算相关的笔记，加深印象"></a>回忆并整理一下以前关于计算机图形学中基础运算相关的笔记，加深印象</h3><h3 id="线性变换："><a href="#线性变换：" class="headerlink" title="线性变换："></a><strong>线性变换</strong>：</h3><p>线性变换是将向量作为输入和输出的一类函数，线性变换就是基向量的变换过程，线性变换矩阵就是变换后基向量的坐标（基向量默认为单位向量）。如果变换矩阵作为行列式其结果表示基向量变换后所构成平行四边形面积或平行六面体体积（如果变换前基向量不为单位向量，则此处为变化率）</p><script type="math/tex; mode=display">\left[\matrix{a&b\\c&d\\}\right]\left[\matrix{x\\y\\}\right]=x\left[\matrix{a\\c\\}\right]+y\left[\matrix{b\\d\\}\right]</script><p>基向量<strong>i</strong>变换后的坐标为（a，c），基向量<strong>j</strong>变换后的坐标为（b，d）</p><p><strong>特点</strong>：保持格网平行且等距的变换，同时保持原点不变。</p><h3 id="Dot（点积或点乘）"><a href="#Dot（点积或点乘）" class="headerlink" title="Dot（点积或点乘）"></a>Dot（点积或点乘）</h3><p><strong>结果</strong>：为一个<strong>值</strong>，表示<strong>b</strong>在<strong>a</strong>上的投影与<strong>a</strong>模的乘积（其实是一个长度，即<strong>b</strong>投影的长度<strong>*a</strong>的长度），当<strong>a</strong>、<strong>b</strong>为单位向量时，值为其夹角的余弦值。</p><p><strong>理解</strong>：点积是一个降维的过程，从上面的结果就可看出，因为投影本身就是降维。 $\vec{a}\cdot\vec{b}$就是将第一个向量<strong>a</strong>转化为（推倒）线性变换矩阵，第二个向量<strong>b</strong>可以看成待变换点。</p><p>计算公式：</p><script type="math/tex; mode=display">\vec{a}\cdot\vec{b} = ||a||*||b||*cos\theta</script><p>点成满足交换律</p><script type="math/tex; mode=display">\vec{a}\cdot\vec{b} = \vec{b}\cdot\vec{a}</script><p>分配律</p><script type="math/tex; mode=display">\vec{a}\cdot(\vec{b} + \vec{c}) = \vec{a}\cdot\vec{b} + \vec{a}\cdot\vec{c}</script><p>结合律</p><script type="math/tex; mode=display">(k*\vec{a})\cdot\vec{b} = \vec{a}\cdot(k*\vec{b}) = k*(\vec{a}\cdot\vec{b})</script><p>二维点积</p><script type="math/tex; mode=display">\vec{a}\cdot\vec{b} = \begin{pmatrix}x_a\\y_b\\\end{pmatrix} * \begin{pmatrix}x_b\\y_a\\\end{pmatrix} = x_ax_b + y_ay_b</script><p>三维点积</p><script type="math/tex; mode=display">\vec{a}\cdot\vec{b} = \begin{pmatrix}x_a\\y_a\\z_a\\\end{pmatrix} * \begin{pmatrix}x_b\\y_b\\z_b\\\end{pmatrix} = x_ax_b + y_ay_b + z_az_b</script><p>点乘作用：</p><ol><li>可以当做<strong>b</strong>在<strong>a</strong>上的投影，根据投影后的结果<strong>b1</strong>对<strong>b</strong>进行分解</li><li>可以判断<strong>a</strong>和<strong>b</strong>的方向</li></ol><h3 id="Cross"><a href="#Cross" class="headerlink" title="Cross"></a>Cross</h3><p><strong>结果</strong>：为一个向量，该向量垂直于<strong>a</strong>、<strong>b</strong>，向量的模（长度大小）为两向量组成平行四边行的面积</p><script type="math/tex; mode=display">||a\times b|| = ||a||*||b||*sin\varphi</script><p>不满足交换律</p><script type="math/tex; mode=display">\vec{a}\times\vec{b} = -\vec{b}\times\vec{a}</script><p>分配律</p><script type="math/tex; mode=display">\vec{a}\times(\vec{b} + \vec{c}) = \vec{a}\times\vec{b} + \vec{a}\times\vec{c}</script><p>结合律</p><script type="math/tex; mode=display">\vec{a}\times(k*\vec{b}) = k*(\vec{a}\times\vec{b})</script><p>三维叉乘</p><script type="math/tex; mode=display">\vec{a}\times\vec{b} = \begin{pmatrix}y_az_b - y_bz_a\\z_ax_b - z_bx_a\\x_ay_b - x_by_a\\\end{pmatrix}</script><p>简化算法</p><script type="math/tex; mode=display">\vec{a}\times\vec{b} = A*\vec{b} = \begin{pmatrix}0 & -z_a & y_a\\z_a & 0 & -x_a\\-y_b & x_a & 0\\\end{pmatrix} * \begin{pmatrix}x_b\\y_b\\z_b\\\end{pmatrix}</script><p>叉乘作用：</p><ol><li>判断左和右，<strong>a</strong> x <strong>b</strong> &gt; 0， 则<strong>b</strong>在<strong>a</strong>的左侧，同理可判断内和外，比如三角形A、B、C三点和待判断点P，若AB x AP与BC x BP和CA x CP结果同正或同负，则点在三角形内</li></ol><p>矩阵：</p><p>满足分配律和结合律</p><script type="math/tex; mode=display">(AB)^T=B^TA^T</script><script type="math/tex; mode=display">AA^{-1}=A^{-1}A=I</script><script type="math/tex; mode=display">(AB)^{-1}=B^{-1}A^{-1}</script>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Cesium中的Clock</title>
    <link href="/2020/05/01/Cesium%E4%B8%AD%E7%9A%84Clock/"/>
    <url>/2020/05/01/Cesium%E4%B8%AD%E7%9A%84Clock/</url>
    
    <content type="html"><![CDATA[<h1 id="Cesium中的Clock类"><a href="#Cesium中的Clock类" class="headerlink" title="Cesium中的Clock类"></a><center>Cesium中的Clock类<center></h1><p>Cesium中的clock主要是为了追踪动画，接收如下参数：</p><pre><code class="hljs javascript">@param &#123;JulianDate&#125; [options.startTime] （动画）开始时间@param &#123;JulianDate&#125; [options.stopTime] 结束时间@param &#123;JulianDate&#125; [options.currentTime] 当前时间 @param &#123;<span class="hljs-built_in">Number</span>&#125; [options.multiplier=<span class="hljs-number">1.0</span>] 快进倍数@param &#123;ClockStep&#125; [options.clockStep=ClockStep.SYSTEM_CLOCK_MULTIPLIER] 决定clock的调用是依赖帧还是系统时钟@param &#123;ClockRange&#125; [options.clockRange=ClockRange.UNBOUNDED] 当到达开始时间或结束时间时应该如何工作（比如LOOP_STOP,循环播放）@param &#123;<span class="hljs-built_in">Boolean</span>&#125; [options.canAnimate=<span class="hljs-literal">true</span>] 是否有动画@param &#123;<span class="hljs-built_in">Boolean</span>&#125; [options.shouldAnimate=<span class="hljs-literal">false</span>] 是否可以开始动画canAnimate和ShouldAnimate同时成立才能有动画</code></pre><p>如果没定义当前时间：如果startTime存在则与其相同，如果stopTime存在则为其前一天，如果两者也都不存在，则以该函数运行时的系统时间作为当前时间：</p><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (!defined(currentTime)) &#123;<span class="hljs-comment">// if not specified, current time is the start time,</span><span class="hljs-comment">// or if that is not specified, 1 day before the stop time,</span><span class="hljs-comment">// or if that is not specified, then now.</span><span class="hljs-keyword">if</span> (defined(startTime)) &#123;currentTime = JulianDate.clone(startTime);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (defined(stopTime)) &#123;currentTime = JulianDate.addDays(stopTime, <span class="hljs-number">-1.0</span>, <span class="hljs-keyword">new</span> JulianDate());&#125; <span class="hljs-keyword">else</span> &#123;currentTime = JulianDate.now();&#125;&#125; <span class="hljs-keyword">else</span> &#123;currentTime = JulianDate.clone(currentTime);&#125;</code></pre><p>JulianDate为儒略日，Cesium提供了JulianDate与UTC（协调世界时）的转换。JulianDate的创建用到了julianDayNumber（儒略日总天数），secondsOfDay（该天中的总秒数），timeStandard（时间标准，默认为UTC）</p><p>如果没有定义startTime，则以currentTime作为其值。如果没有定义stopTime，则以startTime+1天作为stopTime。</p><p>说一下它的几个参数</p><pre><code class="hljs javascript"><span class="hljs-comment">// 时间按照指定间隔跳跃 间隔为multiplier</span>ClockStep.TICK_DEPENDENT: <span class="hljs-number">0</span>,<span class="hljs-comment">// 上次调用至今的系统时间间隔 * multiplier</span><span class="hljs-comment">// 通俗的说就是此次间隔时间按照上一次调用时的间隔时间</span><span class="hljs-comment">// 可以理解为根据帧，但不死板，会根据机器刷新率以及场景</span><span class="hljs-comment">// 动态决定每秒帧数</span>ClockStep.SYSTEM_CLOCK_MULTIPLIER: <span class="hljs-number">1</span>, <span class="hljs-comment">// 将时钟设置为当前系统时间，忽略所有其他设置。</span>ClockStep.SYSTEM_CLOCK : <span class="hljs-number">2</span></code></pre><pre><code class="hljs javascript"><span class="hljs-comment">// 无穷执行，会朝着这个方向一直运行下去，直到海枯石烂</span>ClockRange.UNBOUNDED: <span class="hljs-number">0</span>,<span class="hljs-comment">// 正常执行，会始于startTime止于stopTime（该开始开始，该结束结束）</span>ClockRange.CLAMPED: <span class="hljs-number">1</span>,<span class="hljs-comment">// 循环执行，到结尾了会跳转到开头重新执行</span>ClockRange.LOOP_STOP: <span class="hljs-number">2</span>,</code></pre><p>clock中最为重要的一个函数就是tick了：</p><pre><code class="hljs javascript">Clock.prototype.tick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-comment">// 获取当前时间戳 （getTimestamp有点意思，它返回毫秒，如果你指定了某种时间系统</span>  <span class="hljs-comment">//（performance），它会调用该系统来获取时间，当然你需要去修改该函数的源码。默认</span>  <span class="hljs-comment">// 情况下时间系统未定义，获取的时Date.now()；</span><span class="hljs-keyword">var</span> currentSystemTime = getTimestamp();  <span class="hljs-comment">// 获取"当前"时间（注意，此处this._currentTime表示上一次Clock.tick运行时的值，</span>  <span class="hljs-comment">// 所以准确的说应该叫passTime）</span>  <span class="hljs-keyword">var</span> currentTime = JulianDate.clone(<span class="hljs-keyword">this</span>._currentTime);  <span class="hljs-comment">// 如果动画存在并且应该被播放（也就是说动画被触发了）</span>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.canAnimate &amp;&amp; <span class="hljs-keyword">this</span>._shouldAnimate) &#123;    <span class="hljs-keyword">var</span> clockStep = <span class="hljs-keyword">this</span>._clockStep;    <span class="hljs-comment">// 如果依照当前系统时间</span>    <span class="hljs-keyword">if</span> (clockStep === ClockStep.SYSTEM_CLOCK) &#123;      <span class="hljs-comment">// 获取当前系统时间（JulianDate.now返回的是Date）</span>      currentTime = JulianDate.now(currentTime);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// 否则就先设置乘数</span>    <span class="hljs-keyword">var</span> multiplier = <span class="hljs-keyword">this</span>._multiplier;<span class="hljs-comment">// 以multiplier为间隔</span>    <span class="hljs-keyword">if</span> (clockStep === ClockStep.TICK_DEPENDENT) &#123;        <span class="hljs-comment">// 将currentTime加上multiplier并返回结果</span>      currentTime = JulianDate.addSeconds(currentTime, multiplier, currentTime);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 根据当前帧的系统时间-上一帧的系统时间得出两帧时间差（毫秒）</span>      <span class="hljs-keyword">var</span> milliseconds = currentSystemTime - <span class="hljs-keyword">this</span>._lastSystemTime;        <span class="hljs-comment">// 当前的时间就是currentTime + 上一步求出的时间差，因为时毫秒所以/1000.0</span>    currentTime = JulianDate.addSeconds(currentTime, multiplier * (milliseconds / <span class="hljs-number">1000.0</span>), currentTime);    &#125;    <span class="hljs-keyword">var</span> clockRange = <span class="hljs-keyword">this</span>.clockRange;    <span class="hljs-keyword">var</span> startTime = <span class="hljs-keyword">this</span>.startTime;    <span class="hljs-keyword">var</span> stopTime = <span class="hljs-keyword">this</span>.stopTime;      <span class="hljs-comment">// 如果时一直正常执行模式</span>    <span class="hljs-keyword">if</span> (clockRange === ClockRange.CLAMPED) &#123;        <span class="hljs-comment">// 当前时间小于开始时间</span>    <span class="hljs-keyword">if</span> (JulianDate.lessThan(currentTime, startTime)) &#123;          <span class="hljs-comment">// 将开始时间赋值给当前时间（然后搓搓手耐心的等待开始吧）</span>      currentTime = JulianDate.clone(startTime, currentTime);        <span class="hljs-comment">// 当前时间大于结束时间</span>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (JulianDate.greaterThan(currentTime, stopTime)) &#123;          <span class="hljs-comment">// 不行了，超时了，得抓紧结束，先把结束时间赋值给当前时间</span>      currentTime = JulianDate.clone(stopTime, currentTime);          <span class="hljs-comment">// 提交结束事件</span>    <span class="hljs-keyword">this</span>.onStop.raiseEvent(<span class="hljs-keyword">this</span>);    &#125;      <span class="hljs-comment">// 如果是循环模式  </span>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (clockRange === ClockRange.LOOP_STOP) &#123;        <span class="hljs-comment">// 当前时间小于开始时间，则和上一步一样，将当前时间更新为开始时间</span>      <span class="hljs-keyword">if</span> (JulianDate.lessThan(currentTime, startTime)) &#123;    currentTime = JulianDate.clone(startTime, currentTime);      &#125;        <span class="hljs-comment">// 当前时间大于结束时间</span>    <span class="hljs-keyword">while</span> (JulianDate.greaterThan(currentTime, stopTime)) &#123;        <span class="hljs-comment">// 将大于的部分加上startTime返回给当前时间（嗯，一想确实比较合理）  </span>      currentTime = JulianDate.addSeconds(startTime, JulianDate.secondsDifference(currentTime, stopTime), currentTime);        <span class="hljs-comment">// 提交结束时间</span>      <span class="hljs-keyword">this</span>.onStop.raiseEvent(<span class="hljs-keyword">this</span>);    &#125; &#125;&#125;&#125;  <span class="hljs-comment">// 更新当前时间 </span>  <span class="hljs-keyword">this</span>._currentTime = currentTime;  <span class="hljs-comment">// 更新当前时间（这一帧对应的系统时间）</span>  <span class="hljs-keyword">this</span>._lastSystemTime = currentSystemTime;  <span class="hljs-comment">// 触发回调函数</span>  <span class="hljs-keyword">this</span>.onTick.raiseEvent(<span class="hljs-keyword">this</span>);  <span class="hljs-keyword">return</span> currentTime;&#125;;</code></pre><p>总结来说，其实就是更新currentTime。如果你按照系统时间来更新，那好办，我直接获取系统的<strong>当前时间</strong>，然后return，就省略了80%的代码。如果我按照某个固定时间或者依据帧数时间，就得考虑很多情况，如果当前时间在合理时间区间内，则依据multiplier和对应的计算规则得到当前时间，如果时间超限（小于起始时间或大于终止时间）那么又会根据你动画展示模式分为正常执行和循环执行两种不同处理方式，最终计算得到合理的<strong>当前时间</strong>。</p><p>这里扯一下固定时间和帧数时间，其实就是固定增量时间fixedUpdate和可变增量时间update，固定增量时间就是每两帧运行的时间间隔固定，优点是不用动脑子而且可以当做一个已知量来和物理逻辑或计算进行绑定，缺点是固定就会不灵活。比如给一个动画设置60帧每秒，也就是一帧16.7豪秒左右，也就是说每隔16.7毫秒就会进行一次帧操作，当动画简单时问题不大（当然，本来GPU能进行每秒144帧丝滑刷新的，结果仍然60帧，虽然很不爽但能接受），但复杂时，每帧的执行时间很可能超过16.7毫秒，上一帧还没得出结果还没来得及进行展示，下一帧就不期而遇，慌慌张张的挤了过来，中间可能丢了一些帧，会造成抖动效果（不知道我的理解对不对，欢迎讨论）。</p><p>帧数和刷新率的关系也能扯一些，这里的帧数是指每秒渲染好的画面次数，刷新率是指屏幕显示的刷新率，屏幕每次刷新都要去颜色缓冲区中将渲染好的画面取出来，如果你GPU很强，每秒渲染120帧，可我显示器每秒只能显示60帧，那很抱歉，你每两次中有一次是浪费的，而且帧数太多也不好，我从缓冲区中取画面，取到一半你就又画好了一张，然后我熟若无睹的接着取，这样会造成上半部分是旧帧下半部分是新帧，上下部分内容很可能不匹配（如果某大佬的180°回身甩狙），造成了画面的撕裂。这样催生出了一个产业：显示器将自动和帧率匹配，如英伟达的Gsync技术（是的，按摩店也有freesync，但总是日常180°翻身，但我还是要歇斯底里的吼一句：AMD YES！！）。鄙人前年买笔记本的时候这还是个卖点（1070推144刷新率，也就csgo能达到，守望勉强，最爱玩的战地1、5顶配下也分别只有100-70帧，不过寒霜航空引擎真的牛皮）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS中new的实现</title>
    <link href="/2020/04/27/JS%E4%B8%ADnew%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/04/27/JS%E4%B8%ADnew%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="JS中new的实现以及它背后的故事"><a href="#JS中new的实现以及它背后的故事" class="headerlink" title="JS中new的实现以及它背后的故事"></a><center>JS中new的实现以及它背后的故事<center></h1><h3 id="new的作用"><a href="#new的作用" class="headerlink" title="new的作用"></a>new的作用</h3><p>规范的说：new关键字可以用来创建具有构造函数的<strong>系统内置对象</strong>的实例和<strong>用户自定义类型</strong>对象的实例，通俗的说就是可以通过函数来创建一个实例对象。</p><p>new操作符包含了四个操作（MDN的原文解释）：</p><ol><li>创建一个空的简单JavaScript对象（即{}）；</li><li>链接该对象（即设置该对象的构造函数）到另一个对象；</li><li>将步骤1新创建的对象作为this的上下文；</li><li>如果该函数没有返回对象，则返回this。</li></ol><p>下面结合例子说一下</p><pre><code class="hljs javascript"><span class="hljs-comment">// 构造函数部分</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age</span>) </span>&#123;    <span class="hljs-keyword">this</span>.name = name;    <span class="hljs-keyword">this</span>.age = age;&#125;<span class="hljs-comment">// 原型函数：自我介绍功能</span>Person.prototype.introduce = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello everyone, My name is "</span>  + <span class="hljs-keyword">this</span>.name + <span class="hljs-string">" and I am "</span> + <span class="hljs-keyword">this</span>.age + <span class="hljs-string">" years old"</span>;&#125;<span class="hljs-comment">// 实例对象</span><span class="hljs-keyword">let</span> me = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"yaoyuan"</span>, <span class="hljs-string">"25"</span>) <span class="hljs-comment">// 不错，我已不再年轻</span><span class="hljs-built_in">console</span>.log(me.introduce）</code></pre><p>用代码来解释之前的话就是：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个空对象</span><span class="hljs-keyword">let</span> obj = &#123;&#125;;<span class="hljs-comment">// 将构造函数的原型添加到这个空对象的原型链上</span>obj.__proto__ = Person.prototype;<span class="hljs-comment">// 借用构造函数并传入参数，就是用obj给this赋值</span><span class="hljs-keyword">let</span> result = Person.call(obj, <span class="hljs-built_in">arguments</span>);<span class="hljs-comment">// 如果之前借用构造函数来初始化的result</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">"obj"</span> ? result : obj;</code></pre><p><code>obj.__proto__ = Person.prototype</code> 是为了继承Person中原型链上的属性，<code>Person.call(obj, arguments)</code> 借用构造函数，这两个组合拳使得new关键字的作用和组合继承很想，更准确地说是<strong>寄生组合式</strong>模式。忍不住回顾一下继承的特点（ES5）：</p><p><strong>原型链继承</strong>：</p><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<span class="hljs-comment">// 1行 这里创建了子元素构造函数</span>SubType.prototype = <span class="hljs-keyword">new</span> SuperType(); <span class="hljs-comment">// 2行 这里发生了原型链继承</span><span class="hljs-keyword">let</span> instance = <span class="hljs-keyword">new</span> SubType();<span class="hljs-comment">// 3行 这里实例化的子元素</span></code></pre><p>特点：所有实例共享父元素的所有属性和方法</p><p>缺点：</p><ol><li>不可修改父元素的属性和方法（一但修改所有子实例的对应属性也跟着变）；</li><li><strong>不能给父元素传参数</strong>（借用高程的一句话：”应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数“,又跑到缺点2上面，被所有子元素共享丧失独立性。同时在创建子元素时传的参数进入到了子元素的构造函数内部，父元素实例化时不在子元素的构造函数内部，无法直接很丝滑自然的享受到参数，当然真想赋值也不是没办法就回到了开头高程那句话，禁止套娃）；</li></ol><p><strong>借用构造函数</strong>：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">// 1行 这里创建了子元素构造函数</span>SuperType.call(<span class="hljs-keyword">this</span>);<span class="hljs-comment">// 2行 这里发生了借用构造函数继承</span>&#125;  <span class="hljs-comment">// 3行 这里啥也没干，不写空得慌</span></code></pre><p>特点：所有子元素具有父元素的所有属性和方法，且各自独立互不影响同时还可以传递参数</p><p>缺点：</p><ol><li>每创建一个子元素都会调用一次父元素的构造函数（每个方法都会在每个实例上重新创建一次），没有起到很好的重用效果；</li><li>父元素原型中保留的方法被毫无保留的丢弃了；</li></ol><p><strong>组合继承</strong>：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">// 1行 这里创建了子元素构造函数</span>SuperType.call(<span class="hljs-keyword">this</span>);<span class="hljs-comment">// 2行 这里发生了借用构造函数继承</span>&#125;<span class="hljs-comment">// 3行 这里啥也没干，不写空得慌</span>SubType.prototype = <span class="hljs-keyword">new</span> SuperType();<span class="hljs-comment">// 2行 这里发生了原型链继承</span><span class="hljs-keyword">let</span> instance = <span class="hljs-keyword">new</span> SubType();<span class="hljs-comment">// 3行 这里实例化的子元素</span></code></pre><p>没错，像上面无脑拼接后就是组合继承，赶赶单单，特点：去两个极端之长补两个极端之短</p><p>缺点：无论在什么情况下，都会调用两次超类型的构造函数，一次是在创建子类型的原型时（第2个第2行），另一次是在子类型构造函数内部（第1个第2行。你看，无脑拼接总是会有点瑕疵）</p><p><strong>寄生组合式继承</strong>：</p><p>寄生组合式继承又得扯一堆，长话短说“不必为了指定子类型的原型而调用超类型的构造函数”：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params">name</span>) </span>&#123;<span class="hljs-comment">// 为了体现能传参,象征性的加了一个name</span>SuperType.call(<span class="hljs-keyword">this</span>, name);&#125;<span class="hljs-keyword">let</span> prototype = object(superType.prototype);<span class="hljs-comment">// 对父元素的原型链进行了一次浅复制</span>prototype.constructor = subType;<span class="hljs-comment">// 弥补重写原型而失去的默认constructor属性</span>subType.prototype = prototype;<span class="hljs-comment">// 指定对象</span></code></pre><p>特点：它（指组合继承）的优点就是我的优点，它的缺点还是我的优点</p><p>回到new上来，<code>return typeof result === &quot;obj&quot; ? result : obj;</code>是为了判断上一步（迈在继承畅想之前的那一步） <code>let result = Person.call(obj, arguments)</code>中有没有返回值（即result是否为空），不论如何都会返回这个崭新出厂的obj对象(感觉可以省略掉result的创建，直接返回obj，不太明白为什么不这么做，优雅？“<strong>不太明白</strong>”的地方就是我和大佬毫厘之间千里之外的差距）。</p><h3 id="new的模拟实现"><a href="#new的模拟实现" class="headerlink" title="new的模拟实现"></a>new的模拟实现</h3><p>墙裂推荐<a href="https://github.com/mqyqingfeng" target="_blank" rel="noopener">冴羽</a>的JavaScript深入专栏中的<a href="https://github.com/mqyqingfeng/Blog/issues/13" target="_blank" rel="noopener">new模式实现</a>；</p><p>没事走两步：</p><p>第一步，抓取构造函数指向的原型函数</p><p>第二步，抓取构造函数</p><p>其实new的实现和空对象的寄生组合式继承在思想上非常像</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">NewObject</span>(<span class="hljs-params">...args</span>) </span>&#123;<span class="hljs-comment">// ES6中的三点运算符，对参数位置的情况很适用</span><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();    <span class="hljs-keyword">let</span> Constructor = <span class="hljs-built_in">Array</span>.prototype.shift.call(args);<span class="hljs-comment">// 首先，参数数组args是伪数组，不具备数组的很多方法，因此使用Array.prototype.shift.call()方法来借用，同时shift会修改原数组，移除第一个</span>    <span class="hljs-comment">// 第一步</span>    obj.__proto__ = Constructor.prototype;<span class="hljs-comment">// 实例的原型指向构造函数原型，这样才能实现构造函数中原型函数的继承，直接浅复制拷贝副本，类似寄生组合中对父元素原型链的拷贝</span>    <span class="hljs-comment">// 第二步</span>    Constructor.apply(obj, args);<span class="hljs-comment">// 借用构造函数</span>    <span class="hljs-keyword">return</span> obj;<span class="hljs-comment">// 返回该对象</span>&#125;</code></pre><p>写完了你可能会有疑问：</p><p><img src="data:image/jpeg;base64,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" srcset="/img/loading.gif" alt=""></p><p>（抱歉我的水平就这）</p><p>还记得我之前的“<strong>不太明白</strong>”么？（如果记忆能停留几个7秒的话应该还记得，就在“new的模拟实现”上面第二行），为什么要多此一举的来个result并判断返回值类型呢？</p><p>我和大佬们的差距出来了：构造函数如果有返回值，返回值的类型会对构造的结果产生影响！</p><p>第一种情况：</p><pre><code class="hljs javascript"><span class="hljs-comment">// 之前的例子，函数没有返回值</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age</span>) </span>&#123;    <span class="hljs-keyword">this</span>.name = name;    <span class="hljs-keyword">this</span>.age = age;&#125;<span class="hljs-keyword">let</span> me = <span class="hljs-keyword">new</span> Person (<span class="hljs-string">"耀元"</span>, <span class="hljs-string">"25"</span>);<span class="hljs-built_in">console</span>.log(me.name);<span class="hljs-comment">// “英俊的”（电脑基于客观事实自动补齐）耀元</span><span class="hljs-built_in">console</span>.log(me.age);<span class="hljs-comment">// 25</span></code></pre><p>构造函数没有返回值的时候，构造完毕返回给me元素的是this的值，this的值就是构造函数中一通操作的对象的地址。</p><p>第二种情况：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age</span>) </span>&#123;    <span class="hljs-keyword">this</span>.name = name;    <span class="hljs-keyword">this</span>.age = age;    <span class="hljs-keyword">return</span> &#123;        age: age,        height: <span class="hljs-number">180.0</span>,    &#125;&#125;<span class="hljs-keyword">let</span> me = <span class="hljs-keyword">new</span> Person (<span class="hljs-string">"耀元"</span>, <span class="hljs-string">"25"</span>);<span class="hljs-built_in">console</span>.log(me.name);<span class="hljs-comment">// undefinde (我张某人不配拥有姓名)</span><span class="hljs-built_in">console</span>.log(me.age);<span class="hljs-comment">// 25</span><span class="hljs-built_in">console</span>.log(me.height); <span class="hljs-comment">// 180</span></code></pre><p>上段代码很明显，构造函数里就算构造了一个宇宙没啥作用，因为你传不出来，最终的结果就是你构造函数中最后return的对象。</p><p>第三种情况：</p><p>构造函数返回的是基本类型值</p><p><img src="https://raw.githubusercontent.com/AOldDriverA/BlogFigurebed/master/img/20200427131649.jpg" srcset="/img/loading.gif" alt=""></p><p>大家不要被“英俊的耀元”迷惑了双眼，重点应该放在那段我看不懂的英文上：</p><blockquote><p>Primitive value returned from constructor will be lost when called with ‘new’</p></blockquote><p>用有道的话来说就是：当使用“new”调用构造函数时，基本类型值(string number boolean undefined null 我都试了)会在返回途中丢失（就是return没用，可以忽略这个单词），你收到的就是那个独一无二的构造函数中的对象。</p><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age</span>) </span>&#123;    <span class="hljs-keyword">this</span>.name = name;    <span class="hljs-keyword">this</span>.age = age;    <span class="hljs-keyword">return</span> <span class="hljs-string">"180,180,180"</span><span class="hljs-comment">// 就算是男人们梦寐以求的三个180，它也会当做没看无情抛掉</span>&#125;<span class="hljs-keyword">let</span> me = <span class="hljs-keyword">new</span> Person (<span class="hljs-string">"耀元"</span>, <span class="hljs-string">"25"</span>);<span class="hljs-built_in">console</span>.log(me.name);<span class="hljs-comment">// "耀元"</span><span class="hljs-built_in">console</span>.log(me.age);<span class="hljs-comment">// 25</span></code></pre><p>所以，构造函数返回值的有无和返回类型会影响构造函数的调用结果</p><p>所以，最终版<strong>new</strong>的模拟实现如下：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">NewObject</span> (<span class="hljs-params">...args</span>) </span>&#123;    <span class="hljs-comment">// 新建一个欠返回的对象</span>    <span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();    <span class="hljs-comment">// 获取传入的第一个参数，同时将其从args中删除（shift为删除数组首元素，会改变原数组）</span>    <span class="hljs-comment">// 这里第一个参数为输入的构造函数，其余参数为该构造函数的参数</span>    <span class="hljs-keyword">let</span> Constructor = <span class="hljs-built_in">Array</span>.prototype.shift.call(obj, args);    <span class="hljs-comment">// 将构造函数的原型稳稳的交付给obj,并希望它以后也能用上</span>    obj.__proto__ = Constructor.prototype;    <span class="hljs-comment">// 领着obj走一遍构造流程，把收货再交给result</span>    <span class="hljs-keyword">let</span> result = Constructor.call(obj, args);    <span class="hljs-comment">// 根据result的有无和类型来绝对最终的返回结果。小心点总是好的</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">"object"</span> ? result : obj;&#125;</code></pre><p><strong>OVER</strong>！（看到没，我和大佬的差距看起来只是个result，其实是洋洋洒洒的三分之一篇幅 ( Ĭ ^ Ĭ ) ）</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>深深地被“<strong>最终版new的模拟实现</strong>”中<code>Constructor.call(obj, args)</code>的作风给感动了，构造的过程相当于盖房，收到新雇主obj的买房指令，然后（去堆内存中）找空地根据图纸流程（早已确定的构造函数）进行建造，最后把钥匙（this）交给obj，Constructor则事了拂衣去，深藏功与名，又和人生一样，给新baby（obj）打拼一切，已经有的财产（原型中的方法），可以直接给他，没有的但需要的（构造函数中的属性），从头开始干，最后毫无保留的奉献。你眼中的一个new只是JS开始的第一步，只是一个赶赶单单的返回结果，但其实就是人生的一个缩影，很多时候父母的付出你是看不到的，你看到的只是一个结果。想要一个结果，如果父母有钱可以直接new一个，没钱就得老老实实一步一步来短点三五月长点就是一辈子，虽然最终都是同一个。</p><p><img src="data:image/jpeg;base64,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" srcset="/img/loading.gif" alt=""></p><p>（怎么写成了略微催泪向）</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
